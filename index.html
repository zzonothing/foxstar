<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>ìºë¦­í„° ìŠ¤íƒ¯ í…Œì´ë¸”</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans KR', sans-serif;
            background-color: #f9f9f9;
            color: #333;
            margin: 0;
            padding: 20px;
        }
    
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }
    
        div {
            margin-bottom: 12px;
            text-align: center;
        }
    
        label {
            margin-right: 6px;
            font-weight: 600;
            font-size: 13px;
        }
    
        select {
            padding: 6px 10px;
            margin-right: 8px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background: white;
            font-size: 13px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            transition: border-color 0.3s;
        }
    
        select:focus {
            border-color: #3498db;
            outline: none;
        }
    
        table {
            width: 100%;
            max-width: calc(100vw - 40px);
            margin: 0 auto;
            border-collapse: collapse;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
    
        th,
        td {
            padding: 12px 15px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }

        tbody .character-col {
            text-align: left;
        }
    
        th {
            background-color: #3498db;
            color: white;
            font-weight: 600;
            font-size: 14px;
        }
    
        tr:hover {
            background-color: #f1f7ff;
        }
    
        tbody tr:last-child td {
            border-bottom: none;
        }
    
        .character-image {
            width: 64px;
            height: 64px;
            border-radius: 25%;
            vertical-align: middle;
        }
    
        .character-name {
            display: block;
            font-size: 12px;
            margin-top: 4px;
        }

        #deckDamageInput {
            width: 120px;
            padding: 8px 12px;
            margin-left: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            transition: border-color 0.3s;
            /* ìŠ¤í•€ ë²„íŠ¼ ìˆ¨ê¸°ê¸° */
            -moz-appearance: textfield;
        }
        #deckDamageInput:focus {
            border-color: #3498db;
            outline: none;
        }
        /* Chrome, Safari, Edge, Operaì—ì„œ ìŠ¤í•€ ë²„íŠ¼ ìˆ¨ê¸°ê¸° */
        #deckDamageInput::-webkit-outer-spin-button,
        #deckDamageInput::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .item-grade-SSR {
            color: #FFD700;
        }
        .item-grade-SR {
            color: #A259FF;
        }
        .item-grade-R {
            color: #3498db;
        }

        /* ë²„íŠ¼ ìŠ¤íƒ€ì¼ ì¶”ê°€ */
        .export-button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
        }
        
        .export-button:hover {
            background-color: #45a049;
        }

        /* ì¡°ê±´ í•„í„° ì»¨íŠ¸ë¡¤ ìŠ¤íƒ€ì¼ */
        .condition-controls {
            margin-bottom: 15px;
            padding: 10px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            width: 100%;
            max-width: calc(100vw - 40px);
            margin-left: auto;
            margin-right: auto;
            box-sizing: border-box;
            text-align: center;
        }

        .condition-controls > label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .condition-select-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .condition-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .condition-item label {
            font-weight: 600;
            margin: 0;
            font-size: 12px;
        }

        /* ì»¬ëŸ¼ ì²´í¬ë°•ìŠ¤ ìŠ¤íƒ€ì¼ */
        .column-controls {
            margin-bottom: 15px;
            padding: 10px;
            background: #f1f5f9;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            width: 100%;
            max-width: calc(100vw - 40px);
            margin-left: auto;
            margin-right: auto;
            box-sizing: border-box;
        }

        .column-controls label {
            font-weight: 600;
            margin-right: 12px;
            font-size: 13px;
        }

        .column-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .column-checkbox {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .column-checkbox input[type="checkbox"] {
            margin: 0;
        }

        .column-checkbox span {
            font-size: 12px;
            white-space: nowrap;
        }
    </style>
</head>

<body>
    <div>
        <label for="seasonSelect">ì‹œì¦Œ: </label>
        <select id="seasonSelect"></select>
    </div>
    <div>
        <!-- ë± ì„ íƒ: ë± ëª¨ë“œ ì „í™˜ (ì˜µì…˜ í…ìŠ¤íŠ¸ëŠ” 'ì‹ ìˆ˜í´') -->
        <label for="deckSelect">ë± ì¡°í•©: </label>
        <select id="deckSelect">
            <option value="">-- ë± ì„ íƒ --</option>
            <option value="deck1">ğŸŸª ì „ê²©</option>
            <option value="deck2">ğŸŸ¨ ì² ê°‘</option>
            <option value="deck3">ğŸŸ¥ ì‘ì—´</option>
            <option value="deck4">ğŸŸ¦ ìˆ˜ëƒ‰</option>
            <option value="deck5">ğŸŸ© í’ì••</option>
        </select>
        <label for="deckMemberSelect" style="margin-left:10px;">ë©¤ë²„: </label>
        <select id="deckMemberSelect"></select>
    </div>
    <div>
        <!-- ê°œë³„ ëª¨ë“œìš© ë“œë¡­ë‹¤ìš´ -->
        <label for="characterSelect">ìºë¦­í„°: </label>
        <select id="characterSelect">
            <option value="">-- ì „ì²´ ìºë¦­í„° --</option>
        </select>
    
        <label for="memberSelect">ë©¤ë²„: </label>
        <select id="memberSelect">
            <option value="">-- ì „ì²´ ë©¤ë²„ --</option>
        </select>
    
        <!-- ì •ë ¬ ê¸°ì¤€ (ê°œë³„ ëª¨ë“œì— ì ìš©, ë± ëª¨ë“œì—ì„œëŠ” ë± íŒŒì›Œ ê¸°ì¤€ ì •ë ¬) -->
        <label for="sortSelect">ì •ë ¬: </label>
        <select id="sortSelect">
            <option value="increaseElementDamage">ìš°ì½”</option>
            <option value="increaseAtk">ê³µì¦</option>
        </select>
        
        <button id="exportButton" class="export-button">Excel</button>
    </div>

    <!-- ì¡°ê±´ í•„í„° ì»¨íŠ¸ë¡¤ -->
    <div class="condition-controls">
        <label>ì¡°ê±´:</label>
        <div class="condition-select-container">
            <div class="condition-item">
                <label for="conditionSelect">ì†ì„±:</label>
                <select id="conditionSelect">
                    <option value="">ì „ì²´</option>
                    <option value="deck1">ğŸŸª ì „ê²©</option>
                    <option value="deck2">ğŸŸ¨ ì² ê°‘</option>
                    <option value="deck3">ğŸŸ¥ ì‘ì—´</option>
                    <option value="deck4">ğŸŸ¦ ìˆ˜ëƒ‰</option>
                    <option value="deck5">ğŸŸ© í’ì••</option>
                </select>
            </div>
            <div class="condition-item">
                <label for="elementDamageCondition">ìš°ì½”:</label>
                <select id="elementDamageCondition">
                    <option value="">ì „ì²´</option>
                    <option value="red">ğŸ”´â†‘</option>
                    <option value="orange">ğŸŸ â†‘</option>
                    <option value="yellow">ğŸŸ¡â†‘</option>
                </select>
            </div>
            <div class="condition-item">
                <label for="attackCondition">ê³µì¦:</label>
                <select id="attackCondition">
                    <option value="">ì „ì²´</option>
                    <option value="red">ğŸ”´â†‘</option>
                    <option value="orange">ğŸŸ â†‘</option>
                    <option value="yellow">ğŸŸ¡â†‘</option>
                </select>
            </div>
            <div class="condition-item">
                <label for="itemCondition">ì†Œì¥í’ˆ:</label>
                <select id="itemCondition">
                    <option value="">ì „ì²´</option>
                    <option value="SSR">SSR</option>
                    <option value="SR15">SR 15</option>
                    <option value="SR10">SR 10</option>
                    <option value="SR5">SR 5</option>
                    <option value="SR0">SR 0</option>
                    <option value="R">R</option>
                    <option value="NONE">ì—†ìŒ</option>
                </select>
            </div>
        </div>
        <div class="condition-select-container" style="margin-top: 10px;">
            <div class="condition-item">
                <label for="skill1Condition">ìŠ¤í‚¬1:</label>
                <select id="skill1Condition">
                    <option value="">ì „ì²´</option>
                    <option value="10">10</option>
                    <option value="9">9</option>
                    <option value="8">8</option>
                    <option value="7">7</option>
                    <option value="6">6</option>
                    <option value="5">5</option>
                    <option value="4">4</option>
                    <option value="3">3</option>
                    <option value="2">2</option>
                    <option value="1">1</option>
                </select>
            </div>
            <div class="condition-item">
                <label for="skill2Condition">ìŠ¤í‚¬2:</label>
                <select id="skill2Condition">
                    <option value="">ì „ì²´</option>
                    <option value="10">10</option>
                    <option value="9">9</option>
                    <option value="8">8</option>
                    <option value="7">7</option>
                    <option value="6">6</option>
                    <option value="5">5</option>
                    <option value="4">4</option>
                    <option value="3">3</option>
                    <option value="2">2</option>
                    <option value="1">1</option>
                </select>
            </div>
            <div class="condition-item">
                <label for="skill3Condition">ìŠ¤í‚¬3:</label>
                <select id="skill3Condition">
                    <option value="">ì „ì²´</option>
                    <option value="10">10</option>
                    <option value="9">9</option>
                    <option value="8">8</option>
                    <option value="7">7</option>
                    <option value="6">6</option>
                    <option value="5">5</option>
                    <option value="4">4</option>
                    <option value="3">3</option>
                    <option value="2">2</option>
                    <option value="1">1</option>
                </select>
            </div>
            <div class="condition-item">
                <select id="skillMatchCondition">
                    <option value="ge">ì´ìƒ</option>
                    <option value="eq">ì¼ì¹˜</option>
                </select>
            </div>
        </div>
    </div>

    <!-- ì»¬ëŸ¼ visibility ì»¨íŠ¸ë¡¤ -->
    <div class="column-controls">
        <label>ì»¬ëŸ¼:</label>
        <div class="column-checkboxes" id="columnCheckboxes">
            <!-- JavaScriptë¡œ ë™ì  ìƒì„± -->
        </div>
    </div>

    <!-- ìŠ¤íƒ¯ ì¶œë ¥ í…Œì´ë¸” -->
    <table id="statsTable">
        <thead id="tableHeader">
            <!-- ê¸°ë³¸ ê°œë³„ ëª¨ë“œ í—¤ë” (ë± ëª¨ë“œê°€ ì•„ë‹ ê²½ìš°) -->
            <tr>
                <th>ìˆœìœ„</th>
                <th class="nickname-col">ë‹‰ë„¤ì„</th>
                <th class="character-col">ìºë¦­í„°</th>
                <th>ëŒíŒŒ</th>
                <th>ìš°ì½”xê³µì¦</th>
                <th>ìš°ì½”</th>
                <th>ê³µì¦</th>
                <th>ì°¨ì†</th>
                <th>ì¥íƒ„</th>
                <th>ê³µê²©ë ¥</th>
                <th>ì†Œì¥í’ˆ</th>
                <th>ìŠ¤í‚¬1</th>
                <th>ìŠ¤í‚¬2</th>
                <th>ìŠ¤í‚¬3</th>
            </tr>
        </thead>
        <tbody>
            <!-- JavaScriptë¡œ ë™ì  ìƒì„± -->
        </tbody>
    </table>

    <script>
        function exportTableToCSV() {
            const table = document.getElementById('statsTable');
            let csv = [];
            
            // í—¤ë” ì¶”ì¶œ ìˆ˜ì •
            const headerRow = [];
            const headers = table.querySelectorAll('th');
            const deckMode = document.getElementById('deckSelect').value !== "";
            
            if (deckMode) {
                // ë± ëª¨ë“œì¼ ë•Œ í—¤ë” ì²˜ë¦¬
                headerRow.push('"ìˆœìœ„"', '"ë‹‰ë„¤ì„"', '"ì˜ˆìƒ ëŒ€ë¯¸ì§€"', '"ê¸°ì—¬ë„"');
                
                // ë‚˜ë¨¸ì§€ ì»¬ëŸ¼ í—¤ë” ì¶”ê°€
                headers.forEach(header => {
                    if (!header.hasAttribute('rowspan')) {
                        let headerText = header.textContent.replace(' â–¼', '').trim();
                        headerRow.push(`"${headerText}"`);
                    }
                });
            } else {
                // ê°œë³„ ëª¨ë“œì¼ ë•ŒëŠ” ê¸°ì¡´ ë°©ì‹ ìœ ì§€
                headers.forEach(header => {
                    let headerText = header.textContent.replace(' â–¼', '').trim();
                    headerRow.push(`"${headerText}"`);
                });
            }
            
            csv.push(headerRow.join(','));
            
            // ë°ì´í„° ì¶”ì¶œ
            const rows = table.querySelectorAll('tbody tr');
            let currentMemberData = null;
            
            rows.forEach(row => {
                const rowData = [];
                let cells = row.querySelectorAll('td');
                
                // ì²« ë²ˆì§¸ TDê°€ rowspanì„ ê°€ì§„ ê²½ìš° (ìƒˆë¡œìš´ ë©¤ë²„ì˜ ì‹œì‘)
                if (cells[0].hasAttribute('rowspan')) {
                    currentMemberData = {
                        rank: cells[0].textContent.trim(),
                        memberName: cells[1].textContent.trim(),
                        deckPower: cells[2].textContent.trim()
                    };
                    
                    cells = Array.from(cells).slice(3); // ì˜ˆìƒ ëŒ€ë¯¸ì§€ ì´í›„ ì…€ë¶€í„° ì²˜ë¦¬
                }
                
                // í˜„ì¬ ë©¤ë²„ ë°ì´í„° ì¶”ê°€
                if (currentMemberData) {
                    rowData.push(`"${currentMemberData.rank}"`);
                    rowData.push(`"${currentMemberData.memberName}"`);
                    rowData.push(`"${currentMemberData.deckPower}"`);
                }
                
                // ë‚˜ë¨¸ì§€ ì…€ ë°ì´í„° ì¶”ê°€
                cells.forEach(cell => {
                    let cellText = cell.textContent.trim();
                    rowData.push(`"${cellText}"`);
                });
                
                csv.push(rowData.join(','));
            });
            
            // CSV íŒŒì¼ ìƒì„± ë° ë‹¤ìš´ë¡œë“œ
            const csvContent = csv.join('\n');
            const blob = new Blob(["\ufeff" + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            // í˜„ì¬ ë‚ ì§œì™€ ì‹œì¦Œ, ì†ì„±ì„ íŒŒì¼ëª…ì— í¬í•¨
            const date = new Date().toISOString().slice(0, 10);
            const season = document.getElementById('seasonSelect').value;
            const deck = document.getElementById('deckSelect').value;
            const deckName = deck ? decks[deck].name.split(' ')[1] : 'ì „ì²´';
            const filename = `ìŠ¤íƒ¯í…Œì´ë¸”_ì‹œì¦Œ${season}_${deckName}_${date}.csv`;
            
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
        document.getElementById('exportButton').addEventListener('click', exportTableToCSV);

        // ì»¬ëŸ¼ ì •ì˜ (ë± ëª¨ë“œì™€ ê°œë³„ ëª¨ë“œì— ë”°ë¼ ë‹¤ë¦„)
        const columnDefinitions = {
            normal: [
                { id: 'rank', name: 'ìˆœìœ„', alwaysVisible: true },
                { id: 'nickname', name: 'ë‹‰ë„¤ì„', conditional: true }, // ë©¤ë²„ ì„ íƒì‹œ ìˆ¨ê¹€
                { id: 'level', name: 'ë ˆë²¨', conditional: true }, // ë©¤ë²„ ì„ íƒì‹œ ìˆ¨ê¹€
                { id: 'character', name: 'ìºë¦­í„°', conditional: true }, // ìºë¦­í„° ì„ íƒì‹œ ìˆ¨ê¹€
                { id: 'upgrade', name: 'ëŒíŒŒ' },
                { id: 'increaseElementDamage', name: 'ìš°ì½”' },
                { id: 'increaseAtk', name: 'ê³µì¦' },
                { id: 'ammunition', name: 'ì¥íƒ„', defaultHidden: true },
                { id: 'chargeSpeed', name: 'ì°¨ì†', defaultHidden: true },
                { id: 'chargeDamage', name: 'ì°¨ëŒ', defaultHidden: true },
                { id: 'criticalRate', name: 'í¬í™•', defaultHidden: true },
                { id: 'criticalDamage', name: 'í¬ëŒ', defaultHidden: true },
                { id: 'hitRate', name: 'ëª…ì¤‘', defaultHidden: true },
                { id: 'defenseIncrease', name: 'ë°©ì¦', defaultHidden: true },
                { id: 'attack', name: 'ê³µê²©ë ¥', defaultHidden: true },
                { id: 'item', name: 'ì†Œì¥í’ˆ' },
                { id: 'skill1', name: 'ìŠ¤í‚¬1' },
                { id: 'skill2', name: 'ìŠ¤í‚¬2' },
                { id: 'skill3', name: 'ìŠ¤í‚¬3' }
            ],
            deck: [
                { id: 'rank', name: 'ìˆœìœ„', alwaysVisible: true },
                { id: 'nickname', name: 'ë‹‰ë„¤ì„', alwaysVisible: true },
                { id: 'level', name: 'ë ˆë²¨', alwaysVisible: true },
                { id: 'deckPower', name: 'ì˜ˆìƒ ëŒ€ë¯¸ì§€', alwaysVisible: true },
                { id: 'damageShare', name: 'ê¸°ì—¬ë„', alwaysVisible: true },
                { id: 'character', name: 'ìºë¦­í„°', alwaysVisible: true },
                { id: 'upgrade', name: 'ëŒíŒŒ' },
                { id: 'increaseElementDamage', name: 'ìš°ì½”' },
                { id: 'increaseAtk', name: 'ê³µì¦' },
                { id: 'ammunition', name: 'ì¥íƒ„', defaultHidden: true },
                { id: 'chargeSpeed', name: 'ì°¨ì†', defaultHidden: true },
                { id: 'chargeDamage', name: 'ì°¨ëŒ', defaultHidden: true },
                { id: 'criticalRate', name: 'í¬í™•', defaultHidden: true },
                { id: 'criticalDamage', name: 'í¬ëŒ', defaultHidden: true },
                { id: 'hitRate', name: 'ëª…ì¤‘', defaultHidden: true },
                { id: 'defenseIncrease', name: 'ë°©ì¦', defaultHidden: true },
                { id: 'attack', name: 'ê³µê²©ë ¥', defaultHidden: true },
                { id: 'item', name: 'ì†Œì¥í’ˆ' },
                { id: 'skill1', name: 'ìŠ¤í‚¬1' },
                { id: 'skill2', name: 'ìŠ¤í‚¬2' },
                { id: 'skill3', name: 'ìŠ¤í‚¬3' }
            ]
        };

        // í˜„ì¬ ë³´ì´ëŠ” ì»¬ëŸ¼ë“¤ ìƒíƒœ ê´€ë¦¬
        let visibleColumns = {};



        // ì¸ë±ìŠ¤ë¡œ ì»¬ëŸ¼ ID ê°€ì ¸ì˜¤ê¸°
        function getColumnIdByIndex(index) {
            const deckMode = document.getElementById('deckSelect').value !== "";
            const selectedCharacter = document.getElementById('characterSelect').value;
            const selectedMember = document.getElementById('memberSelect').value;
            
            let columns = columnDefinitions[deckMode ? 'deck' : 'normal'];
            
            // ì¡°ê±´ë¶€ ì»¬ëŸ¼ í•„í„°ë§
            if (!deckMode) {
                columns = columns.filter(column => {
                    if (column.conditional) {
                        if (column.id === 'nickname' && selectedMember) return false;
                        if (column.id === 'level' && selectedMember) return false;
                        if (column.id === 'character' && selectedCharacter) return false;
                    }
                    return true;
                });
            }
            
            return columns[index] ? columns[index].id : null;
        }

        // ë± êµ¬ì„± ì •ë³´ë¥¼ ë¯¸ë¦¬ ì •ì˜ (ì¶”í›„ ë±ì´ ì¶”ê°€ë  ë•Œ ìœ ì—°í•˜ê²Œ ì ìš©)
        const decks = {
            deck1: {
                name: 'ğŸŸª ì „ê²©',
                characters: [
                    { weight: 1, type: 'element', name: 'ì‹ ë°ë ë¼' },
                    { weight: 1, type: 'element', name: 'ì•„ë‹ˆìŠ¤ : ìŠ¤íŒŒí´ë§ ì„œë¨¸' },
                    { weight: 1, type: 'element', name: 'ë©”ì´ë“  : ì•„ì´ìŠ¤ ë¡œì¦ˆ' },
                    { weight: 1, type: 'element', name: 'ë£¨ì£¼' },
                    { weight: 1, type: 'element', name: 'ë§ˆë¦¬' },
                ]
            },
            deck2: {
                name: 'ğŸŸ¨ ì² ê°‘',
                characters: [
                    { weight: 1, type: 'element', name: 'ë¼í”¼ : ë ˆë“œ í›„ë“œ' },
                    { weight: 1, type: 'element', name: 'ë ˆë“œ í›„ë“œ' },
                    { weight: 1, type: 'element', name: 'ì´ë¸Œ' },
                    { weight: 1, type: 'element', name: 'ë ˆì´ë¸' },
                    { weight: 1, type: 'element', name: 'ìŠ¤ë…¸ìš° í™”ì´íŠ¸' }
                ]
            },
            deck3: { 
                name: 'ğŸŸ¥ ì‘ì—´',
                characters: [
                    { weight: 1, type: 'element', name: 'ë¼í”¼ : ë ˆë“œ í›„ë“œ'  },
                    { weight: 1, type: 'element', name: 'ë¯¸í•˜ë¼ : ë³¸ë”© ì²´ì¸' },
                    { weight: 1, type: 'element', name: 'ì•¨ë¦¬ìŠ¤' },
                    { weight: 1, type: 'element', name: 'ì•„ìŠ¤ì¹´' },
                    { weight: 1, type: 'element', name: 'ë ˆì´' },
                    { weight: 1, type: 'element', name: 'ëª¨ë”ë‹ˆì•„' },
                ]
            },
            deck4: {
                name: 'ğŸŸ¦ ìˆ˜ëƒ‰',
                characters: [
                    { weight: 1, type: 'element', name: 'ë„ë¡œì‹œ : ì„¸ë Œë””í”¼í‹°' },
                    { weight: 1, type: 'element', name: 'í—¬ë¦„' },
                    { weight: 1, type: 'element', name: 'ë£¨ë“œë°€ë¼ : ìœˆí„° ì˜¤ë„ˆ' },
                    { weight: 1, type: 'element', name: 'ì¼ë ˆê·¸ : ë¶ ì•¤ ì‡¼í¬' },
                    { weight: 1, type: 'element', name: 'ë¸Œë˜ë””' },
                    { weight: 1, type: 'element', name: 'í€€ì‹œ : ì´ìŠ¤ì¼€ì´í”„ í€¸' },
                ]
            },
            deck5: {
                name: 'ğŸŸ© í’ì••',
                characters: [
                    { weight: 1, type: 'element', name: 'í™ë ¨ : í‘ì˜' },
                    { weight: 1, type: 'element', name: 'ì•„ìŠ¤ì¹´ : WILLE' },
                    { weight: 1, type: 'element', name: 'ë ˆì´ (ê°€ì¹­)' },
                    { weight: 1, type: 'element', name: 'ë¦¬í‹€ ë¨¸ë©”ì´ë“œ' },
                    { weight: 1, type: 'element', name: 'ë§ˆë‚˜' },
                ]
            }
        };

        fetch('data/data.json')
            .then(response => response.json())
            .then(data => {
                const seasonSelect = document.getElementById('seasonSelect');
                const seasons = Object.keys(data.seasons).sort((a, b) => b - a); // ìˆ«ì ë‚´ë¦¼ì°¨ìˆœ
                seasons.forEach(season => {
                    const option = document.createElement('option');
                    option.value = season;
                    option.textContent = `ì‹œì¦Œ ${season}`;
                    seasonSelect.appendChild(option);
                });

                let members = data.seasons[seasons[0]].members; // ìµœì‹  ì‹œì¦Œìœ¼ë¡œ ê¸°ë³¸ ì„¤ì •

                // DOM ìš”ì†Œë“¤ì„ ì „ì—­ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ ì„ ì–¸
                const selectDeck = document.getElementById('deckSelect');
                const selectCharacter = document.getElementById('characterSelect');
                const selectMember = document.getElementById('memberSelect');
                const selectSort = document.getElementById('sortSelect');
                const selectCondition = document.getElementById('conditionSelect');
                const elementDamageConditionSelect = document.getElementById('elementDamageCondition');
                const attackConditionSelect = document.getElementById('attackCondition');
                const itemConditionSelect = document.getElementById('itemCondition');
                const skill1ConditionSelect = document.getElementById('skill1Condition');
                const skill2ConditionSelect = document.getElementById('skill2Condition');
                const skill3ConditionSelect = document.getElementById('skill3Condition');
                const skillMatchConditionSelect = document.getElementById('skillMatchCondition');
                const tbody = document.getElementById('statsTable').querySelector('tbody');
                const tableHeader = document.getElementById('tableHeader');
                const deckMemberSelect = document.getElementById('deckMemberSelect');

                seasonSelect.addEventListener('change', () => {
                    const selectedSeason = seasonSelect.value;
                    members = data.seasons[selectedSeason].members;
                    updateTable(); // í…Œì´ë¸”ì„ ë‹¤ì‹œ ê·¸ë¦½ë‹ˆë‹¤
                });

                // ì»¬ëŸ¼ ê°€ì‹œì„± ì—…ë°ì´íŠ¸ í•¨ìˆ˜
                function updateColumnVisibility() {
                    console.log('updateColumnVisibility í˜¸ì¶œë¨', visibleColumns);
                    // ì²´í¬ë°•ìŠ¤ ì¬ìƒì„± ì—†ì´ í…Œì´ë¸”ë§Œ ë‹¤ì‹œ ë Œë”ë§
                    renderTableContent();
                }
                
                // ìš°ì½” ê°’ì— ë”°ë¥¸ ìƒ‰ìƒ ì› ì¶”ê°€ í•¨ìˆ˜
                function getElementDamageDisplay(value) {
                    let circle = '';
                    if (value >= 94.24) {
                        circle = 'ğŸ”´';
                    } else if (value >= 70.68) {
                        circle = 'ğŸŸ ';
                    } else if (value >= 47.12) {
                        circle = 'ğŸŸ¡';
                    } else {
                        circle = 'âšª';
                    }
                    return `${circle} ${value}`;
                }

                // ìš°ì½” ì¡°ê±´ ì²´í¬ í•¨ìˆ˜
                function checkElementDamageCondition(value, condition) {
                    if (!condition) return true;
                    
                    switch (condition) {
                        case 'red':
                            return value >= 94.24;
                        case 'orange':
                            return value >= 70.68;
                        case 'yellow':
                            return value >= 47.12;
                        default:
                            return true;
                    }
                }
                
                // ê³µì¦ ê°’ì— ë”°ë¥¸ ìƒ‰ìƒ ì› ì¶”ê°€ í•¨ìˆ˜
                function getAttackDisplay(value) {
                    let circle = '';
                    if (value >= 47.24) {
                        circle = 'ğŸ”´';
                    } else if (value >= 35.43) {
                        circle = 'ğŸŸ ';
                    } else if (value >= 23.62) {
                        circle = 'ğŸŸ¡';
                    } else {
                        circle = 'âšª';
                    }
                    return `${circle} ${value}`;
                }

                // ê³µì¦ ì¡°ê±´ ì²´í¬ í•¨ìˆ˜
                function checkAttackCondition(value, condition) {
                    if (!condition) return true;
                    
                    switch (condition) {
                        case 'red':
                            return value >= 47.24;
                        case 'orange':
                            return value >= 35.43;
                        case 'yellow':
                            return value >= 23.62;
                        default:
                            return true;
                    }
                }

                // ì†Œì¥í’ˆ ì¡°ê±´ ì²´í¬ í•¨ìˆ˜
                function checkItemCondition(itemGrade, itemLevel, condition) {
                    if (!condition) return true;
                    
                    switch (condition) {
                        case 'SSR':
                            return itemGrade === 'SSR';
                        case 'SR15':
                            return itemGrade === 'SR' && itemLevel === 15;
                        case 'SR10':
                            return itemGrade === 'SR' && itemLevel >= 10 && itemLevel <= 14;
                        case 'SR5':
                            return itemGrade === 'SR' && itemLevel >= 5 && itemLevel <= 9;
                        case 'SR0':
                            return itemGrade === 'SR' && itemLevel >= 0 && itemLevel <= 4;
                        case 'R':
                            return itemGrade === 'R';
                        case 'NONE':
                            return !itemGrade || itemGrade === '';
                        default:
                            return true;
                    }
                }

                // ìŠ¤í‚¬ ì¡°ê±´ ì²´í¬ í•¨ìˆ˜
                function checkSkillConditions(skill1, skill2, skill3, skill1Condition, skill2Condition, skill3Condition, matchCondition) {
                    if (!skill1Condition && !skill2Condition && !skill3Condition) return true;
                    
                    const isMatch = matchCondition === 'eq';
                    
                    // ìŠ¤í‚¬1 ì¡°ê±´ ì²´í¬
                    if (skill1Condition) {
                        const targetValue = parseInt(skill1Condition);
                        const skillValue = parseInt(skill1) || 0;
                        
                        if (isMatch) {
                            if (skillValue !== targetValue) return false;
                        } else {
                            if (skillValue < targetValue) return false;
                        }
                    }
                    
                    // ìŠ¤í‚¬2 ì¡°ê±´ ì²´í¬
                    if (skill2Condition) {
                        const targetValue = parseInt(skill2Condition);
                        const skillValue = parseInt(skill2) || 0;
                        
                        if (isMatch) {
                            if (skillValue !== targetValue) return false;
                        } else {
                            if (skillValue < targetValue) return false;
                        }
                    }
                    
                    // ìŠ¤í‚¬3 ì¡°ê±´ ì²´í¬
                    if (skill3Condition) {
                        const targetValue = parseInt(skill3Condition);
                        const skillValue = parseInt(skill3) || 0;
                        
                        if (isMatch) {
                            if (skillValue !== targetValue) return false;
                        } else {
                            if (skillValue < targetValue) return false;
                        }
                    }
                    
                    return true;
                }
                
                // í…Œì´ë¸” ë‚´ìš©ë§Œ ë Œë”ë§í•˜ëŠ” í•¨ìˆ˜ (ì²´í¬ë°•ìŠ¤ ì¬ìƒì„± ì—†ìŒ) - ì„±ëŠ¥ ìµœì í™”
                function renderTableContent() {
                    const startTime = performance.now();
                    const deckMode = selectDeck.value !== "";
                    const selectedCharacter = selectCharacter.value;
                    const selectedMember = selectMember.value;
                    const sortBy = selectSort.value;
                    const selectedCondition = selectCondition.value;
                    const elementDamageCondition = document.getElementById('elementDamageCondition').value;
                    const attackCondition = document.getElementById('attackCondition').value;
                    const itemCondition = document.getElementById('itemCondition').value;
                    const skill1Condition = document.getElementById('skill1Condition').value;
                    const skill2Condition = document.getElementById('skill2Condition').value;
                    const skill3Condition = document.getElementById('skill3Condition').value;
                    const skillMatchCondition = document.getElementById('skillMatchCondition').value;
                    
                    // DocumentFragment ì‚¬ìš©ìœ¼ë¡œ DOM ì¡°ì‘ ìµœì í™”
                    const fragment = document.createDocumentFragment();
                    tbody.innerHTML = "";

                    if (deckMode) {
                        // ë± ëª¨ë“œ: ë±ì— ì •ì˜ëœ ëª¨ë“  ìºë¦­í„°ë¥¼ ë³´ìœ í•œ ë©¤ë²„ë§Œ í‘œì‹œ
                        const deck = decks[selectDeck.value];
                        let deckData = [];
                        members.forEach(member => {
                            let deckStats = [];
                            let hasAll = true;
                            deck.characters.forEach(deckChar => {
                                const charData = member.characters.find(c => c.name === deckChar.name);
                                if (charData) {
                                    // ê° ìºë¦­í„°ë³„ ê³„ì‚°
                                    const elementPower = Math.round(charData.atk * (1 + charData.increaseAtk / 200) * (1 + charData.increaseElementDamage / 100));
                                    const nonElementPower = Math.round(charData.atk * (1 + charData.increaseAtk / 200));
                                    const elementPlusAtk = Math.round(((1 + charData.increaseAtk / 200) * (1 + charData.increaseElementDamage / 100) - 1) * 10000) / 100;                                    
                                    const trainingLevel = elementPlusAtk;

                                    deckStats.push({
                                        characterName: deckChar.name,
                                        upgrade: charData.upgrade,
                                        elementPower: elementPower,
                                        nonElementPower: nonElementPower,
                                        elementPlusAtk: elementPlusAtk,
                                        increaseElementDamage: charData.increaseElementDamage || 0,
                                        increaseAtk: charData.increaseAtk || 0,
                                        increaseChargeSpeed: charData.increaseChargeSpeed || 0,
                                        increaseMaxAmmunitionCapacity: charData.increaseMaxAmmunitionCapacity || 0,
                                        increaseChargeDamage: charData.increaseChargeDamage || 0,
                                        increaseCriticalRate: charData.increaseCriticalRate || 0,
                                        increaseCriticalDamage: charData.increaseCriticalDamage || 0,
                                        increaseHitRate: charData.increaseHitRate || 0,
                                        increaseDef: charData.increaseDef || 0,
                                        atk: charData.atk,
                                        skill1: charData.skill1,
                                        skill2: charData.skill2,
                                        skill3: charData.skill3,
                                        weight: deckChar.weight,
                                        type: deckChar.type,
                                        itemGrade: charData.itemGrade,
                                        itemLevel: charData.itemLevel,
                                        trainingLevel: trainingLevel,
                                        element: charData.element,
                                    });
                                } else {
                                    hasAll = false;
                                }
                            });
                            if (hasAll && deckStats.length > 0) {
                                // ì¡°ê±´ í•„í„°ë§ ì ìš© (AND ì¡°ê±´)
                                const passesConditions = deckStats.every(stat => {
                                    // ìš°ì½” ì¡°ê±´ ì²´í¬
                                    if (!checkElementDamageCondition(stat.increaseElementDamage, elementDamageCondition)) {
                                        return false;
                                    }
                                    // ê³µì¦ ì¡°ê±´ ì²´í¬  
                                    if (!checkAttackCondition(stat.increaseAtk, attackCondition)) {
                                        return false;
                                    }
                                    // ì†Œì¥í’ˆ ì¡°ê±´ ì²´í¬
                                    if (!checkItemCondition(stat.itemGrade, stat.itemLevel, itemCondition)) {
                                        return false;
                                    }
                                    // ìŠ¤í‚¬ ì¡°ê±´ ì²´í¬
                                    if (!checkSkillConditions(stat.skill1, stat.skill2, stat.skill3, skill1Condition, skill2Condition, skill3Condition, skillMatchCondition)) {
                                        return false;
                                    }
                                    return true;
                                });

                                if (!passesConditions) return;

                                if (deck.name === 'ì‹ ë° ìˆ˜ë‹ˆìŠ¤ í´ì´ë“ ') {
                                    const cinde = deckStats.find(c => c.characterName === "ì‹ ë°ë ë¼");
                                    const sunis = deckStats.find(c => c.characterName === "ì•„ë‹ˆìŠ¤ : ìŠ¤íŒŒí´ë§ ì„œë¨¸");
                                    const chrismasMaiden = deckStats.find(c => c.characterName === "ë©”ì´ë“  : ì•„ì´ìŠ¤ ë¡œì¦ˆ");

                                    const cindeRealElementPower = Math.round((cinde.atk * (1 + cinde.increaseAtk / 100) + (sunis.atk * 1.1) + (chrismasMaiden.atk * 0.4)) * (1 + cinde.increaseElementDamage / 100));
                                    const deckPower = Math.round(16 * cindeRealElementPower + 5 * sunis.elementPower + 6 * chrismasMaiden.elementPower);
                                    
                                    deckData.push({
                                        memberName: member.name,
                                        syncroLevel: member.syncroLevel,
                                        deckPower: deckPower,
                                        deckStats: deckStats
                                    });
                                }
                                else {
                                    let expectedDamage = 0;
                                    
                                    // ì „ê²© ë±ì¸ ê²½ìš° ì˜ˆìƒ ëŒ€ë¯¸ì§€ ê³„ì‚°
                                    if (selectDeck.value === 'deck1') {
                                        const cinde = deckStats.find(c => c.characterName === "ì‹ ë°ë ë¼");
                                        const sunis = deckStats.find(c => c.characterName === "ì•„ë‹ˆìŠ¤ : ìŠ¤íŒŒí´ë§ ì„œë¨¸");
                                        const chiden = deckStats.find(c => c.characterName === "ë©”ì´ë“  : ì•„ì´ìŠ¤ ë¡œì¦ˆ");
                                        const mari = deckStats.find(c => c.characterName === "ë§ˆë¦¬");
                                        const rouge = deckStats.find(c => c.characterName === "ë£¨ì£¼");
                                        
                                        if (cinde && sunis && chiden && mari && rouge) {
                                            // ì‹ ë°ë ë¼ ì˜ˆì¸¡ ëŒ€ë¯¸ì§€
                                            const cindeDamage = (cinde.atk + (cinde.atk * (cinde.increaseAtk/100)) + (sunis.atk * 0.5531) + (chiden.atk * 0.209) + (mari.atk * 0.1453) + (rouge.atk * 0.1507)) * ((100 + cinde.increaseElementDamage + 19.09 + 10) / 100) * 1.4764 * 4887;
                                            
                                            // ìˆ˜ë‹ˆìŠ¤ ì˜ˆì¸¡ ëŒ€ë¯¸ì§€
                                            const sunisDamage = (sunis.atk + (sunis.atk * (sunis.increaseAtk/100)) + (sunis.atk * 0.5531) + (chiden.atk * 0.209) + (mari.atk * 0.1453) + (rouge.atk * 0.1507)) * ((100 + sunis.increaseElementDamage + 19.09 + 10) / 100) * 1.4764 * 1901;
                                            
                                            // í´ì´ë“  ì˜ˆì¸¡ ëŒ€ë¯¸ì§€
                                            const chidenDamage = (chiden.atk + (chiden.atk * (chiden.increaseAtk/100)) + (sunis.atk * 0.5531) + (mari.atk * 0.1453) + (rouge.atk * 0.1507)) * ((100 + chiden.increaseElementDamage + 19.09 + 10) / 100) * 1.4764 * 2084;
                                            
                                            // ë§ˆë¦¬ ì˜ˆì¸¡ ëŒ€ë¯¸ì§€
                                            const mariDamage = (mari.atk + (mari.atk * (mari.increaseAtk/100)) + (sunis.atk * 0.5531) + (chiden.atk * 0.209) + (mari.atk * 0.2907) + (rouge.atk * 0.1507)) * ((100 + mari.increaseElementDamage + 19.09 + 10) / 100) * 1.4764 * 808;
                                            
                                            // ë£¨ì£¼ ì˜ˆì¸¡ ëŒ€ë¯¸ì§€
                                            const rougeDamage = (rouge.atk + (rouge.atk * (rouge.increaseAtk/100)) + (sunis.atk * 0.5531) + (chiden.atk * 0.209) + (mari.atk * 0.1453) + (rouge.atk * 0.1507)) * ((100 + rouge.increaseElementDamage + 19.09 + 10) / 100) * 1.4764 * 657;
                                            
                                            expectedDamage = Math.round(cindeDamage + sunisDamage + chidenDamage + mariDamage + rougeDamage);
                                            
                                            // ê° ìºë¦­í„°ë³„ ì§€ë¶„ ê³„ì‚°í•˜ì—¬ ì €ì¥
                                            deckStats.forEach(stat => {
                                                if (stat.characterName === "ì‹ ë°ë ë¼") {
                                                    stat.damageShare = ((cindeDamage / expectedDamage) * 100).toFixed(2) + "%";
                                                } else if (stat.characterName === "ì•„ë‹ˆìŠ¤ : ìŠ¤íŒŒí´ë§ ì„œë¨¸") {
                                                    stat.damageShare = ((sunisDamage / expectedDamage) * 100).toFixed(2) + "%";
                                                } else if (stat.characterName === "ë©”ì´ë“  : ì•„ì´ìŠ¤ ë¡œì¦ˆ") {
                                                    stat.damageShare = ((chidenDamage / expectedDamage) * 100).toFixed(2) + "%";
                                                } else if (stat.characterName === "ë§ˆë¦¬") {
                                                    stat.damageShare = ((mariDamage / expectedDamage) * 100).toFixed(2) + "%";
                                                } else if (stat.characterName === "ë£¨ì£¼") {
                                                    stat.damageShare = ((rougeDamage / expectedDamage) * 100).toFixed(2) + "%";
                                                }
                                            });
                                        }
                                    }
                                    
                                    deckData.push({
                                        memberName: member.name,
                                        syncroLevel: member.syncroLevel,
                                        deckPower: expectedDamage,
                                        deckStats: deckStats
                                    });
                                }
                            }
                        });
                        deckData.sort((a, b) => b.deckPower - a.deckPower);
                        
                        updateDeckHeader();
                        
                        deckData.forEach((data, index) => {
                            const rowCount = data.deckStats.length;
                            
                            data.deckStats.forEach((stat, i) => {
                                const tr = document.createElement("tr");
                                
                                // ì»¬ëŸ¼ ë°ì´í„° ë§¤í•‘
                                const columnData = {
                                    rank: index + 1,
                                    nickname: data.memberName,
                                    level: data.syncroLevel,
                                    character: `${stat.element !== "" ? (elementEmojis[stat.element] + ' ') : ''} ${stat.characterName}`,
                                    upgrade: stat.upgrade,
                                    deckPower: data.deckPower.toLocaleString(),
                                    damageShare: stat.damageShare || "0.00%",
                                    increaseElementDamage: getElementDamageDisplay(stat.increaseElementDamage),
                                    increaseAtk: getAttackDisplay(stat.increaseAtk),
                                    ammunition: stat.increaseMaxAmmunitionCapacity,
                                    chargeSpeed: stat.increaseChargeSpeed,
                                    chargeDamage: stat.increaseChargeDamage,
                                    criticalRate: stat.increaseCriticalRate,
                                    criticalDamage: stat.increaseCriticalDamage,
                                    hitRate: stat.increaseHitRate,
                                    defenseIncrease: stat.increaseDef,
                                    attack: stat.atk.toLocaleString(),
                                    item: (stat.itemGrade !== undefined && stat.itemGrade !== '' && stat.itemLevel !== undefined) ? `<span class="item-grade-${stat.itemGrade}">${stat.itemGrade} ${stat.itemLevel}</span>` : '',
                                    skill1: stat.skill1,
                                    skill2: stat.skill2,
                                    skill3: stat.skill3
                                };
                                
                                let cellsHtml = '';
                                const columns = columnDefinitions.deck;
                                
                                columns.forEach(column => {
                                    if (visibleColumns[column.id] !== false) {
                                        let cellContent = columnData[column.id];
                                        let cellAttributes = '';
                                        
                                        // íŠ¹ë³„í•œ ì†ì„± ì²˜ë¦¬
                                        if (column.id === 'character') {
                                            cellAttributes = ' class="character-col"';
                                        }
                                        if (column.id === 'chargeSpeed' && stat.characterName === "ì•¨ë¦¬ìŠ¤" && stat.increaseChargeSpeed <= 8) {
                                            cellAttributes = ' style="color:red"';
                                        }
                                        
                                        // rowspan ì²˜ë¦¬ (ì²« ë²ˆì§¸ í–‰ì—ì„œë§Œ)
                                        if (i === 0 && ['rank', 'nickname', 'level', 'deckPower'].includes(column.id)) {
                                            cellAttributes += ` rowspan="${rowCount}"`;
                                        } else if (i > 0 && ['rank', 'nickname', 'level', 'deckPower'].includes(column.id)) {
                                            // ì²« ë²ˆì§¸ í–‰ì´ ì•„ë‹Œ ê²½ìš° rowspan ì»¬ëŸ¼ì€ ìƒëµ
                                            return;
                                        }
                                        
                                        cellsHtml += `<td${cellAttributes}>${cellContent}</td>`;
                                    }
                                });
                                
                                tr.innerHTML = cellsHtml;
                                fragment.appendChild(tr);
                            });
                        });
                    } else {
                        // ê°œë³„ ëª¨ë“œ: ê¸°ì¡´ í•„í„°(ìºë¦­í„°, ë©¤ë²„ ì„ íƒ) ë° ì •ë ¬ ê¸°ëŠ¥ ì ìš©
                        let selectedData = [];
                        members.forEach(member => {
                            member.characters.forEach(character => {
                                if ((selectedCharacter && character.name !== selectedCharacter) ||
                                    (selectedMember && member.name !== selectedMember)) {
                                    return;
                                }
                                
                                // ì¡°ê±´ í•„í„°ë§ ì ìš© (element ê¸°ë°˜)
                                if (selectedCondition && selectedCondition !== "") {
                                    // ë± IDë¥¼ elementë¡œ ë§¤í•‘
                                    const deckToElement = {
                                        "deck1": "ì „ê²©",
                                        "deck2": "ì² ê°‘", 
                                        "deck3": "ì‘ì—´",
                                        "deck4": "ìˆ˜ëƒ‰",
                                        "deck5": "í’ì••"
                                    };
                                    
                                    const targetElement = deckToElement[selectedCondition];
                                    if (targetElement && character.element !== targetElement) {
                                        return;
                                    }
                                }

                                // ìš°ì½” ì¡°ê±´ ì²´í¬
                                if (!checkElementDamageCondition(character.increaseElementDamage || 0, elementDamageCondition)) {
                                    return;
                                }

                                // ê³µì¦ ì¡°ê±´ ì²´í¬
                                if (!checkAttackCondition(character.increaseAtk || 0, attackCondition)) {
                                    return;
                                }

                                // ì†Œì¥í’ˆ ì¡°ê±´ ì²´í¬
                                if (!checkItemCondition(character.itemGrade, character.itemLevel, itemCondition)) {
                                    return;
                                }

                                // ìŠ¤í‚¬ ì¡°ê±´ ì²´í¬
                                if (!checkSkillConditions(character.skill1, character.skill2, character.skill3, skill1Condition, skill2Condition, skill3Condition, skillMatchCondition)) {
                                    return;
                                }
                                const elementPlusAtk = Math.round(((1 + character.increaseAtk / 200) * (1 + character.increaseElementDamage / 100) - 1) * 10000) / 100;                                
                                const trainingLevel = elementPlusAtk;

                                selectedData.push({
                                    memberName: member.name,                                    
                                    syncroLevel: member.syncroLevel,
                                    characterName: character.name,
                                    upgrade: character.upgrade,
                                    elementPower: Math.round(character.atk * (1 + character.increaseAtk / 200) * (1 + character.increaseElementDamage / 100)),
                                    nonElementPower: Math.round(character.atk * (1 + character.increaseAtk / 200)),
                                    elementPlusAtk: Math.round(((1 + character.increaseAtk / 200) * (1 + character.increaseElementDamage / 100) - 1) * 10000) / 100,
                                    increaseElementDamage: character.increaseElementDamage || 0,
                                    increaseAtk: character.increaseAtk || 0,
                                    increaseChargeSpeed: character.increaseChargeSpeed || 0,
                                    increaseMaxAmmunitionCapacity: character.increaseMaxAmmunitionCapacity || 0,
                                    increaseChargeDamage: character.increaseChargeDamage || 0,
                                    increaseCriticalRate: character.increaseCriticalRate || 0,
                                    increaseCriticalDamage: character.increaseCriticalDamage || 0,
                                    increaseHitRate: character.increaseHitRate || 0,
                                    increaseDef: character.increaseDef || 0,
                                    atk: character.atk,
                                    skill1: character.skill1,
                                    skill2: character.skill2,
                                    skill3: character.skill3,
                                    itemGrade: character.itemGrade,
                                    itemLevel: character.itemLevel,
                                    trainingLevel: trainingLevel,
                                    element: character.element,
                                });
                            });
                        });
                        selectedData.sort((a, b) => b[sortBy] - a[sortBy]);

                        const showNickname = selectedMember ? false : true;
                        const showCharacter = selectedCharacter ? false : true;

                        updateNormalHeader(sortBy, showNickname, showCharacter);

                        selectedData.forEach((data, index) => {
                            const tr = document.createElement("tr");
                            
                            // ì»¬ëŸ¼ ë°ì´í„° ë§¤í•‘
                            const columnData = {
                                rank: index + 1,
                                nickname: data.memberName,
                                level: data.syncroLevel,
                                character: `${data.element ? (elementEmojis[data.element] + ' ') : ''} ${data.characterName}`,
                                upgrade: data.upgrade,
                                increaseElementDamage: getElementDamageDisplay(data.increaseElementDamage),
                                increaseAtk: getAttackDisplay(data.increaseAtk),
                                ammunition: data.increaseMaxAmmunitionCapacity,
                                chargeSpeed: data.increaseChargeSpeed,
                                chargeDamage: data.increaseChargeDamage,
                                criticalRate: data.increaseCriticalRate,
                                criticalDamage: data.increaseCriticalDamage,
                                hitRate: data.increaseHitRate,
                                defenseIncrease: data.increaseDef,
                                attack: data.atk.toLocaleString(),
                                item: (data.itemGrade !== undefined && data.itemGrade !== '' && data.itemLevel !== undefined) ? `<span class="item-grade-${data.itemGrade}">${data.itemGrade} ${data.itemLevel}</span>` : '',
                                skill1: data.skill1,
                                skill2: data.skill2,
                                skill3: data.skill3
                            };
                            
                            let cellsHtml = '';
                            let columns = columnDefinitions.normal;
                            
                            // ì¡°ê±´ë¶€ ì»¬ëŸ¼ í•„í„°ë§
                            columns = columns.filter(column => {
                                if (column.conditional) {
                                    if (column.id === 'nickname' && selectedMember) return false;
                                    if (column.id === 'level' && selectedMember) return false;
                                    if (column.id === 'character' && selectedCharacter) return false;
                                }
                                return true;
                            });
                            
                            columns.forEach(column => {
                                if (visibleColumns[column.id] !== false) {
                                    let cellContent = columnData[column.id];
                                    let cellAttributes = '';
                                    
                                    // íŠ¹ë³„í•œ ì†ì„± ì²˜ë¦¬
                                    if (column.id === 'character') {
                                        cellAttributes = ' class="character-col"';
                                    }
                                    if (column.id === 'chargeSpeed' && data.characterName === "ì•¨ë¦¬ìŠ¤" && data.increaseChargeSpeed <= 8) {
                                        cellAttributes = ' style="color:red"';
                                    }
                                    
                                    cellsHtml += `<td${cellAttributes}>${cellContent}</td>`;
                                }
                            });
                            
                            tr.innerHTML = cellsHtml;
                            fragment.appendChild(tr);
                        });
                    }
                    
                    // í•œ ë²ˆì— ëª¨ë“  í–‰ì„ tbodyì— ì¶”ê°€ (ì„±ëŠ¥ ìµœì í™”)
                    tbody.appendChild(fragment);
                    
                    // ì„±ëŠ¥ ì¸¡ì •
                    const endTime = performance.now();
                    console.log(`í…Œì´ë¸” ë Œë”ë§ ì‹œê°„: ${(endTime - startTime).toFixed(2)}ms`);
                }

                // ì»¬ëŸ¼ ì²´í¬ë°•ìŠ¤ ìƒì„± í•¨ìˆ˜
                function createColumnCheckboxes(mode = 'normal') {
                    const container = document.getElementById('columnCheckboxes');
                    container.innerHTML = '';
                    
                    const columns = columnDefinitions[mode];
                    const selectedCharacter = selectCharacter.value;
                    const selectedMember = selectMember.value;
                    
                    columns.forEach(column => {
                        // ì¡°ê±´ë¶€ ì»¬ëŸ¼ ì²´í¬
                        if (column.conditional) {
                            if (column.id === 'nickname' && selectedMember) return;
                            if (column.id === 'level' && selectedMember) return;
                            if (column.id === 'character' && selectedCharacter) return;
                        }
                        
                        const checkboxDiv = document.createElement('div');
                        checkboxDiv.className = 'column-checkbox';
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.id = `col-${column.id}`;
                        
                        // ê¸°ë³¸ê°’ ì„¤ì •: defaultHiddenì´ trueì´ë©´ unchecked, ì•„ë‹ˆë©´ checked
                        if (visibleColumns[column.id] === undefined) {
                            visibleColumns[column.id] = !column.defaultHidden;
                        }
                        checkbox.checked = visibleColumns[column.id];
                        
                        const span = document.createElement('span');
                        span.textContent = column.name;
                        
                        checkboxDiv.appendChild(checkbox);
                        checkboxDiv.appendChild(span);
                        container.appendChild(checkboxDiv);
                        
                        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€ (ë””ë°”ìš´ì‹± ì ìš©)
                        let debounceTimer;
                        checkbox.addEventListener('change', function() {
                            console.log(`ì²´í¬ë°•ìŠ¤ ${column.id} ë³€ê²½ë¨:`, this.checked);
                            visibleColumns[column.id] = this.checked;
                            
                            // ë””ë°”ìš´ì‹±: ë¹ ë¥¸ ì—°ì† í´ë¦­ì„ ë°©ì§€í•˜ì—¬ ì„±ëŠ¥ í–¥ìƒ
                            clearTimeout(debounceTimer);
                            debounceTimer = setTimeout(() => {
                                console.log('renderTableContent í˜¸ì¶œ (ë””ë°”ìš´ì‹±)');
                                renderTableContent();
                            }, 50); // 50ms ì§€ì—°
                        });
                    });
                }


                // ê°œë³„ ëª¨ë“œìš© ë“œë¡­ë‹¤ìš´ ì±„ìš°ê¸°: ìºë¦­í„°, ë©¤ë²„ ëª©ë¡
                const characterNamesSet = new Set();
                const memberNamesSet = [];

                members.sort((a, b) => b.syncroLevel - a.syncroLevel).forEach(member => {
                    memberNamesSet.push({ name: member.name, syncroLevel: member.syncroLevel });
                    member.characters.forEach(character => {
                        characterNamesSet.add(character.name);
                    });
                });

                // íŠ¹ì • ìºë¦­í„°ë¥¼ ìµœìƒë‹¨ì— ìœ„ì¹˜ì‹œí‚¤ê¸°
                const priorityCharacters = [
                    // ì „ê²©
                    "ğŸ’œ ì‹ ë°ë ë¼",
                    "ğŸ’œ ì•„ë‹ˆìŠ¤ : ìŠ¤íŒŒí´ë§ ì„œë¨¸",
                    "ğŸ’œ ë©”ì´ë“  : ì•„ì´ìŠ¤ ë¡œì¦ˆ",                     
                    // í’ì••
                    "ğŸ’š í™ë ¨ : í‘ì˜", 
                    "ğŸ’š ì•„ìŠ¤ì¹´ : WILLE",
                    "ğŸ’š ë ˆì´ (ê°€ì¹­)",
                    "ğŸ’š ë¦¬í‹€ ë¨¸ë©”ì´ë“œ",
                    // ì‘ì—´
                    "â¤ï¸ ì•¨ë¦¬ìŠ¤", 
                    "â¤ï¸ ë¯¸í•˜ë¼ : ë³¸ë”© ì²´ì¸",
                    "â¤ï¸ ì•„ìŠ¤ì¹´",
                    "â¤ï¸ ë ˆì´",
                    "â¤ï¸ ëª¨ë”ë‹ˆì•„",
                    // ì² ê°‘
                    "ğŸ’› ë¼í”¼ : ë ˆë“œ í›„ë“œ", 
                    "ğŸ’› ë ˆë“œ í›„ë“œ",
                    "ğŸ’› ì´ë¸Œ",
                    "ğŸ’› ë ˆì´ë¸",
                    "ğŸ’› ìŠ¤ë…¸ìš° í™”ì´íŠ¸",
                    // ìˆ˜ëƒ‰
                    "ğŸ’™ ë„ë¡œì‹œ : ì„¸ë Œë””í”¼í‹°", 
                    "ğŸ’™ í—¬ë¦„", 
                    "ğŸ’™ ë£¨ë“œë°€ë¼ : ìœˆí„° ì˜¤ë„ˆ",
                    "ğŸ’™ ì¼ë ˆê·¸ : ë¶ ì•¤ ì‡¼í¬",
                    "ğŸ’™ í€€ì‹œ : ì´ìŠ¤ì¼€ì´í”„ í€¸",
                    "ğŸ’™ ë¸Œë˜ë””",
                    "ğŸ’™ ì¼ë ˆê·¸ : ë¶ ì•¤ ì‡¼í¬"
                ];

                // priorityCharacters ë°°ì—´ ìœ„ì— element ë§¤í•‘ ì¶”ê°€
                const elementEmojis = {
                    "ì „ê²©": "ğŸŸª",
                    "ì² ê°‘": "ğŸŸ¨",
                    "ì‘ì—´": "ğŸŸ¥", 
                    "ìˆ˜ëƒ‰": "ğŸŸ¦",
                    "í’ì••": "ğŸŸ©"
                };
                
                // ìš°ì„ ìˆœìœ„ ìºë¦­í„°ë¥¼ ë¨¼ì € ì¶”ê°€
                priorityCharacters.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name.slice(3); // ì´ëª¨ì§€ ì œê±°
                    option.innerHTML = name;
                    selectCharacter.appendChild(option);
                });

                const sortedCharacters = Array.from(characterNamesSet)
                    .sort()
                    .filter(name => !priorityCharacters.includes(name)); // ìš°ì„ ìˆœìœ„ ìºë¦­í„° ì œì™¸

                // ë‚˜ë¨¸ì§€ ìºë¦­í„°ë¥¼ ì´ë¦„ ìˆœìœ¼ë¡œ ì¶”ê°€
                sortedCharacters.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    selectCharacter.appendChild(option);
                });

                memberNamesSet.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member.name;
                    option.textContent = `${member.name} (${member.syncroLevel})`;
                    selectMember.appendChild(option);
                });

                function updateDeckMemberSelect() {
                    // í˜„ì¬ ì„ íƒëœ ê°’ ì €ì¥
                    const prevValue = deckMemberSelect.value;
                    deckMemberSelect.innerHTML = '<option value="">-- ë©¤ë²„ ì„ íƒ --</option>';
                    members.forEach(member => {
                        const option = document.createElement('option');
                        option.value = member.name;
                        option.textContent = `${member.name} (${member.syncroLevel})`;
                        deckMemberSelect.appendChild(option);
                    });
                    // ì´ì „ ì„ íƒê°’ ë³µì›
                    if (prevValue) deckMemberSelect.value = prevValue;
                }

                // ê°œë³„ ëª¨ë“œ í—¤ë” ì—…ë°ì´íŠ¸ (ì •ë ¬ ê¸°ì¤€ ì»¬ëŸ¼ ìš°ì¸¡ì— â–¼ í‘œì‹œ)
                function updateNormalHeader(sortBy, showNickname, showCharacter) {
                    let columns = columnDefinitions.normal;
                    
                    // ì¡°ê±´ë¶€ ì»¬ëŸ¼ í•„í„°ë§
                    columns = columns.filter(column => {
                        if (column.conditional) {
                            if (column.id === 'nickname' && !showNickname) return false;
                            if (column.id === 'level' && !showNickname) return false;
                            if (column.id === 'character' && !showCharacter) return false;
                        }
                        return true;
                    });
                    
                    let headerHtml = '<tr>';
                    columns.forEach(column => {
                        if (visibleColumns[column.id] !== false) {
                            let headerText = column.name;
                            let headerClass = '';
                            
                            // ì •ë ¬ í‘œì‹œ
                            const headers = {
                                "increaseElementDamage": "ìš°ì½”",
                                "increaseAtk": "ê³µì¦"
                            };
                            
                            if (headers[sortBy] === column.name) {
                                headerText += " â–¼";
                            }
                            
                            // íŠ¹ë³„í•œ í´ë˜ìŠ¤ ì²˜ë¦¬
                            if (column.id === 'nickname') {
                                headerClass = ' class="nickname-col"';
                            } else if (column.id === 'character') {
                                headerClass = ' class="character-col"';
                            }
                            
                            headerHtml += `<th${headerClass}>${headerText}</th>`;
                        }
                    });
                    headerHtml += '</tr>';
                    
                    tableHeader.innerHTML = headerHtml;
                }

                // ë± ëª¨ë“œìš© í—¤ë” ì—…ë°ì´íŠ¸ (ë‹¨ì¼ í–‰ í—¤ë”)
                function updateDeckHeader() {
                    const columns = columnDefinitions.deck;
                    let headerHtml = '<tr>';
                    
                    columns.forEach(column => {
                        if (visibleColumns[column.id] !== false) {
                            let rowspanAttr = '';
                            let headerText = column.name;
                            
                            // rowspanì´ í•„ìš”í•œ ì»¬ëŸ¼ë“¤
                            if (['rank', 'nickname', 'level', 'deckPower'].includes(column.id)) {
                                rowspanAttr = ' rowspan="2"';
                            }
                            
                            // ì •ë ¬ í‘œì‹œ
                            if (column.id === 'deckPower') {
                                headerText += ' â–¼';
                            }
                            
                            headerHtml += `<th${rowspanAttr}>${headerText}</th>`;
                        }
                    });
                    
                    headerHtml += '</tr>';
                    tableHeader.innerHTML = headerHtml;
                }

                // updateTable í•¨ìˆ˜: ë± ëª¨ë“œì™€ ê°œë³„ ëª¨ë“œë¥¼ ëª¨ë‘ ì§€ì›
                function updateTable() {
                    const deckMode = selectDeck.value !== "";
                    updateDeckMemberSelect();
                    
                    // ì»¬ëŸ¼ ì²´í¬ë°•ìŠ¤ ì—…ë°ì´íŠ¸
                    createColumnCheckboxes(deckMode ? 'deck' : 'normal');
                    
                    // í…Œì´ë¸” ë‚´ìš© ë Œë”ë§
                    renderTableContent();
                }

                // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
                selectDeck.addEventListener("change", updateTable);
                selectCharacter.addEventListener("change", updateTable);
                selectMember.addEventListener("change", updateTable);
                selectSort.addEventListener("change", updateTable);
                selectCondition.addEventListener("change", updateTable);
                elementDamageConditionSelect.addEventListener("change", updateTable);
                attackConditionSelect.addEventListener("change", updateTable);
                itemConditionSelect.addEventListener("change", updateTable);
                skill1ConditionSelect.addEventListener("change", updateTable);
                skill2ConditionSelect.addEventListener("change", updateTable);
                skill3ConditionSelect.addEventListener("change", updateTable);
                skillMatchConditionSelect.addEventListener("change", updateTable);
                deckMemberSelect.addEventListener("change", updateTable);

                // ì´ˆê¸° í—¤ë” ì„¤ì • (ê°œë³„ ëª¨ë“œ ê¸°ë³¸)
                updateNormalHeader(selectSort.value);
                
                // ì´ˆê¸° ì»¬ëŸ¼ ì²´í¬ë°•ìŠ¤ ìƒì„±
                createColumnCheckboxes('normal');

                updateTable(); // ì´ˆê¸° í…Œì´ë¸” ì—…ë°ì´íŠ¸
            })
            .catch(error => console.error("JSON íŒŒì¼ ë¡œë”© ì¤‘ ì˜¤ë¥˜:", error));
    </script>
</body>

</html>