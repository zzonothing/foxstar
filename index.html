<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>캐릭터 스탯 테이블</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans KR', sans-serif;
            background-color: #f9f9f9;
            color: #333;
            margin: 0;
            padding: 20px;
        }
    
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }
    
        div {
            margin-bottom: 20px;
            text-align: center;
        }
    
        label {
            margin-right: 8px;
            font-weight: 600;
        }
    
        select {
            padding: 8px 12px;
            margin-right: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            transition: border-color 0.3s;
        }
    
        select:focus {
            border-color: #3498db;
            outline: none;
        }
    
        table {
            width: 100%;
            max-width: calc(100vw - 40px);
            margin: 0 auto;
            border-collapse: collapse;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
    
        th,
        td {
            padding: 12px 15px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }

        tbody .character-col {
            text-align: left;
        }
    
        th {
            background-color: #3498db;
            color: white;
            font-weight: 600;
            font-size: 14px;
        }
    
        tr:hover {
            background-color: #f1f7ff;
        }
    
        tbody tr:last-child td {
            border-bottom: none;
        }
    
        .character-image {
            width: 64px;
            height: 64px;
            border-radius: 25%;
            vertical-align: middle;
        }
    
        .character-name {
            display: block;
            font-size: 12px;
            margin-top: 4px;
        }

        #deckDamageInput {
            width: 120px;
            padding: 8px 12px;
            margin-left: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            transition: border-color 0.3s;
            /* 스핀 버튼 숨기기 */
            -moz-appearance: textfield;
        }
        #deckDamageInput:focus {
            border-color: #3498db;
            outline: none;
        }
        /* Chrome, Safari, Edge, Opera에서 스핀 버튼 숨기기 */
        #deckDamageInput::-webkit-outer-spin-button,
        #deckDamageInput::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .item-grade-SSR {
            color: #FFD700;
        }
        .item-grade-SR {
            color: #A259FF;
        }
        .item-grade-R {
            color: #3498db;
        }

        /* 버튼 스타일 추가 */
        .export-button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
        }
        
        .export-button:hover {
            background-color: #45a049;
        }

        /* 컬럼 체크박스 스타일 */
        .column-controls {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            width: 100%;
            max-width: calc(100vw - 40px);
            margin-left: auto;
            margin-right: auto;
            box-sizing: border-box;
        }

        .column-controls label {
            font-weight: 600;
            margin-right: 15px;
        }

        .column-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
        }

        .column-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .column-checkbox input[type="checkbox"] {
            margin: 0;
        }

        .column-checkbox span {
            font-size: 14px;
            white-space: nowrap;
        }
    </style>
</head>

<body>
    <div>
        <label for="seasonSelect">시즌 선택: </label>
        <select id="seasonSelect"></select>
    </div>
    <div>
        <!-- 덱 선택: 덱 모드 전환 (옵션 텍스트는 '신수클') -->
        <label for="deckSelect">덱 선택: </label>
        <select id="deckSelect">
            <option value="">-- 덱 선택 --</option>
            <option value="deck1">🟪 전격</option>
            <option value="deck2">🟨 철갑</option>
            <option value="deck3">🟥 작열</option>
            <option value="deck4">🟦 수냉</option>
            <option value="deck5">🟩 풍압</option>
        </select>
        <select id="deckMemberSelect" style="margin-left:10px;"></select>
    </div>
    <div>
        <!-- 개별 모드용 드롭다운 -->
        <label for="characterSelect">캐릭터 선택: </label>
        <select id="characterSelect">
            <option value="">-- 전체 캐릭터 --</option>
        </select>
    
        <label for="memberSelect">멤버 선택: </label>
        <select id="memberSelect">
            <option value="">-- 전체 멤버 --</option>
        </select>
    
        <!-- 정렬 기준 (개별 모드에 적용, 덱 모드에서는 덱 파워 기준 정렬) -->
        <label for="sortSelect">정렬 기준: </label>
        <select id="sortSelect">
            <option value="trainingLevel">육성</option>
            <option value="elementPlusAtk">우코x공증</option>
            <option value="increaseElementDamage">우코</option>
            <option value="increaseAtk">공증</option>
        </select>
        <button id="exportButton" class="export-button">Excel</button>
    </div>

    <!-- 컬럼 visibility 컨트롤 -->
    <div class="column-controls">
        <label>컬럼:</label>
        <div class="column-checkboxes" id="columnCheckboxes">
            <!-- JavaScript로 동적 생성 -->
        </div>
    </div>

    <!-- 스탯 출력 테이블 -->
    <table id="statsTable">
        <thead id="tableHeader">
            <!-- 기본 개별 모드 헤더 (덱 모드가 아닐 경우) -->
            <tr>
                <th>순위</th>
                <th class="nickname-col">닉네임</th>
                <th class="character-col">캐릭터</th>
                <th>돌파</th>
                <th>우코x공증</th>
                <th>우코</th>
                <th>공증</th>
                <th>차속</th>
                <th>장탄</th>
                <th>공격력</th>
                <th>소장품</th>
                <th>스킬1</th>
                <th>스킬2</th>
                <th>스킬3</th>
            </tr>
        </thead>
        <tbody>
            <!-- JavaScript로 동적 생성 -->
        </tbody>
    </table>

    <script>
        function exportTableToCSV() {
            const table = document.getElementById('statsTable');
            let csv = [];
            
            // 헤더 추출 수정
            const headerRow = [];
            const headers = table.querySelectorAll('th');
            const deckMode = document.getElementById('deckSelect').value !== "";
            
            if (deckMode) {
                // 덱 모드일 때 헤더 처리
                headerRow.push('"순위"', '"닉네임"', '"덱파워"');
                
                // 나머지 컬럼 헤더 추가
                headers.forEach(header => {
                    if (!header.hasAttribute('rowspan')) {
                        let headerText = header.textContent.replace(' ▼', '').trim();
                        headerRow.push(`"${headerText}"`);
                    }
                });
            } else {
                // 개별 모드일 때는 기존 방식 유지
                headers.forEach(header => {
                    let headerText = header.textContent.replace(' ▼', '').trim();
                    headerRow.push(`"${headerText}"`);
                });
            }
            
            csv.push(headerRow.join(','));
            
            // 데이터 추출
            const rows = table.querySelectorAll('tbody tr');
            let currentMemberData = null;
            
            rows.forEach(row => {
                const rowData = [];
                let cells = row.querySelectorAll('td');
                
                // 첫 번째 TD가 rowspan을 가진 경우 (새로운 멤버의 시작)
                if (cells[0].hasAttribute('rowspan')) {
                    currentMemberData = {
                        rank: cells[0].textContent.trim(),
                        memberName: cells[1].textContent.trim(),
                        deckPower: cells[2].textContent.trim()
                    };
                    
                    // 예상 대미지 컬럼이 있는 경우
                    if (cells[3].hasAttribute('rowspan')) {
                        currentMemberData.expectedDamage = cells[3].textContent.trim();
                        cells = Array.from(cells).slice(4); // 예상 대미지 이후 셀부터 처리
                    } else {
                        cells = Array.from(cells).slice(3); // 덱파워 이후 셀부터 처리
                    }
                }
                
                // 현재 멤버 데이터 추가
                if (currentMemberData) {
                    rowData.push(`"${currentMemberData.rank}"`);
                    rowData.push(`"${currentMemberData.memberName}"`);
                    rowData.push(`"${currentMemberData.deckPower}"`);
                    if (currentMemberData.expectedDamage !== undefined) {
                        rowData.push(`"${currentMemberData.expectedDamage}"`);
                    }
                }
                
                // 나머지 셀 데이터 추가
                cells.forEach(cell => {
                    let cellText = cell.textContent.trim();
                    rowData.push(`"${cellText}"`);
                });
                
                csv.push(rowData.join(','));
            });
            
            // CSV 파일 생성 및 다운로드
            const csvContent = csv.join('\n');
            const blob = new Blob(["\ufeff" + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            // 현재 날짜와 시즌, 속성을 파일명에 포함
            const date = new Date().toISOString().slice(0, 10);
            const season = document.getElementById('seasonSelect').value;
            const deck = document.getElementById('deckSelect').value;
            const deckName = deck ? decks[deck].name.split(' ')[1] : '전체';
            const filename = `스탯테이블_시즌${season}_${deckName}_${date}.csv`;
            
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // 이벤트 리스너 등록
        document.getElementById('exportButton').addEventListener('click', exportTableToCSV);

        // 컬럼 정의 (덱 모드와 개별 모드에 따라 다름)
        const columnDefinitions = {
            normal: [
                { id: 'rank', name: '순위', alwaysVisible: true },
                { id: 'nickname', name: '닉네임', conditional: true }, // 멤버 선택시 숨김
                { id: 'level', name: '레벨', conditional: true }, // 멤버 선택시 숨김
                { id: 'character', name: '캐릭터', conditional: true }, // 캐릭터 선택시 숨김
                { id: 'upgrade', name: '돌파' },
                { id: 'elementPlusAtk', name: '파워' },
                { id: 'increaseElementDamage', name: '우코' },
                { id: 'increaseAtk', name: '공증' },
                { id: 'ammunition', name: '장탄' },
                { id: 'chargeSpeed', name: '차속', defaultHidden: true },
                { id: 'chargeDamage', name: '차댐', defaultHidden: true },
                { id: 'criticalRate', name: '크확', defaultHidden: true },
                { id: 'criticalDamage', name: '크댐', defaultHidden: true },
                { id: 'hitRate', name: '명중', defaultHidden: true },
                { id: 'defenseIncrease', name: '방증', defaultHidden: true },
                { id: 'attack', name: '공격력', defaultHidden: true },
                { id: 'item', name: '소장품' },
                { id: 'skill1', name: '스킬1' },
                { id: 'skill2', name: '스킬2' },
                { id: 'skill3', name: '스킬3' }
            ],
            deck: [
                { id: 'rank', name: '순위', alwaysVisible: true },
                { id: 'nickname', name: '닉네임', alwaysVisible: true },
                { id: 'level', name: '레벨', alwaysVisible: true },
                { id: 'character', name: '캐릭터', alwaysVisible: true },
                { id: 'upgrade', name: '돌파' },
                { id: 'deckPower', name: '덱파워', alwaysVisible: true },
                { id: 'elementPlusAtk', name: '파워' },
                { id: 'increaseElementDamage', name: '우코' },
                { id: 'increaseAtk', name: '공증' },
                { id: 'ammunition', name: '장탄' },
                { id: 'chargeSpeed', name: '차속', defaultHidden: true },
                { id: 'chargeDamage', name: '차댐', defaultHidden: true },
                { id: 'criticalRate', name: '크확', defaultHidden: true },
                { id: 'criticalDamage', name: '크댐', defaultHidden: true },
                { id: 'hitRate', name: '명중', defaultHidden: true },
                { id: 'defenseIncrease', name: '방증', defaultHidden: true },
                { id: 'attack', name: '공격력', defaultHidden: true },
                { id: 'item', name: '소장품' },
                { id: 'skill1', name: '스킬1' },
                { id: 'skill2', name: '스킬2' },
                { id: 'skill3', name: '스킬3' }
            ]
        };

        // 현재 보이는 컬럼들 상태 관리
        let visibleColumns = {};

        // 컬럼 체크박스 생성 함수
        function createColumnCheckboxes(mode = 'normal') {
            const container = document.getElementById('columnCheckboxes');
            container.innerHTML = '';
            
            const columns = columnDefinitions[mode];
            const selectedCharacter = document.getElementById('characterSelect').value;
            const selectedMember = document.getElementById('memberSelect').value;
            
            columns.forEach(column => {
                // 조건부 컬럼 체크
                if (column.conditional) {
                    if (column.id === 'nickname' && selectedMember) return;
                    if (column.id === 'level' && selectedMember) return;
                    if (column.id === 'character' && selectedCharacter) return;
                }
                
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'column-checkbox';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `col-${column.id}`;
                
                // 기본값 설정: defaultHidden이 true이면 unchecked, 아니면 checked
                if (visibleColumns[column.id] === undefined) {
                    visibleColumns[column.id] = !column.defaultHidden;
                }
                checkbox.checked = visibleColumns[column.id];
                
                const span = document.createElement('span');
                span.textContent = column.name;
                
                checkboxDiv.appendChild(checkbox);
                checkboxDiv.appendChild(span);
                container.appendChild(checkboxDiv);
                
                // 이벤트 리스너 추가
                checkbox.addEventListener('change', function() {
                    visibleColumns[column.id] = this.checked;
                    updateColumnVisibility();
                });
            });
        }

        // 컬럼 가시성 업데이트 함수
        function updateColumnVisibility() {
            // 체크박스 재생성 없이 테이블만 다시 렌더링
            renderTableContent();
        }
        
        // 테이블 내용만 렌더링하는 함수 (체크박스 재생성 없음)
        function renderTableContent() {
            const deckMode = selectDeck.value !== "";
            const selectedCharacter = selectCharacter.value;
            const selectedMember = selectMember.value;
            const sortBy = selectSort.value;
            tbody.innerHTML = "";

            if (deckMode) {
                // 덱 모드: 덱에 정의된 모든 캐릭터를 보유한 멤버만 표시
                const deck = decks[selectDeck.value];
                let deckData = [];
                members.forEach(member => {
                    let deckStats = [];
                    let hasAll = true;
                    deck.characters.forEach(deckChar => {
                        const charData = member.characters.find(c => c.name === deckChar.name);
                        if (charData) {
                            // 각 캐릭터별 계산
                            const elementPower = Math.round(charData.atk * (1 + charData.increaseAtk / 200) * (1 + charData.increaseElementDamage / 100));
                            const nonElementPower = Math.round(charData.atk * (1 + charData.increaseAtk / 200));
                            const elementPlusAtk = Math.round(((1 + charData.increaseAtk / 200) * (1 + charData.increaseElementDamage / 100) - 1) * 10000) / 100;                                    
                            const trainingLevel = elementPlusAtk;

                            deckStats.push({
                                characterName: deckChar.name,
                                upgrade: charData.upgrade,
                                elementPower: elementPower,
                                nonElementPower: nonElementPower,
                                elementPlusAtk: elementPlusAtk,
                                increaseElementDamage: charData.increaseElementDamage || 0,
                                increaseAtk: charData.increaseAtk || 0,
                                increaseChargeSpeed: charData.increaseChargeSpeed || 0,
                                increaseMaxAmmunitionCapacity: charData.increaseMaxAmmunitionCapacity || 0,
                                increaseChargeDamage: charData.increaseChargeDamage || 0,
                                increaseCriticalRate: charData.increaseCriticalRate || 0,
                                increaseCriticalDamage: charData.increaseCriticalDamage || 0,
                                increaseHitRate: charData.increaseHitRate || 0,
                                increaseDef: charData.increaseDef || 0,
                                atk: charData.atk,
                                skill1: charData.skill1,
                                skill2: charData.skill2,
                                skill3: charData.skill3,
                                weight: deckChar.weight,
                                type: deckChar.type,
                                itemGrade: charData.itemGrade,
                                itemLevel: charData.itemLevel,
                                trainingLevel: trainingLevel,
                                element: charData.element,
                            });
                        } else {
                            hasAll = false;
                        }
                    });
                    if (hasAll && deckStats.length > 0) {
                        if (deck.name === '신데 수니스 클이든') {
                            const cinde = deckStats.find(c => c.characterName === "신데렐라");
                            const sunis = deckStats.find(c => c.characterName === "아니스 : 스파클링 서머");
                            const chrismasMaiden = deckStats.find(c => c.characterName === "메이든 : 아이스 로즈");

                            const cindeRealElementPower = Math.round((cinde.atk * (1 + cinde.increaseAtk / 100) + (sunis.atk * 1.1) + (chrismasMaiden.atk * 0.4)) * (1 + cinde.increaseElementDamage / 100));
                            const deckPower = Math.round(16 * cindeRealElementPower + 5 * sunis.elementPower + 6 * chrismasMaiden.elementPower);
                            
                            deckData.push({
                                memberName: member.name,
                                syncroLevel: member.syncroLevel,
                                deckPower: deckPower,
                                deckStats: deckStats
                            });
                        }
                        else {
                            const deckPower = deckStats.reduce((sum, curr) => sum + curr.elementPlusAtk, 0);
                            deckData.push({
                                memberName: member.name,
                                syncroLevel: member.syncroLevel,
                                deckPower: deckPower,
                                deckStats: deckStats
                            });
                        }
                    }
                });
                deckData.sort((a, b) => b.deckPower - a.deckPower);
                
                updateDeckHeader();
                
                deckData.forEach((data, index) => {
                    const rowCount = data.deckStats.length;
                    
                    data.deckStats.forEach((stat, i) => {
                        const tr = document.createElement("tr");
                        
                        // 컬럼 데이터 매핑
                        const columnData = {
                            rank: index + 1,
                            nickname: data.memberName,
                            level: data.syncroLevel,
                            character: `${stat.element !== "" ? (elementEmojis[stat.element] + ' ') : ''} ${stat.characterName}`,
                            upgrade: stat.upgrade,
                            deckPower: data.deckPower.toLocaleString(),
                            elementPlusAtk: `${(stat.trainingLevel >= 100 ? '🔴' : 
                                stat.trainingLevel >= 80 ? '🟠' : 
                                stat.trainingLevel >= 60 ? '🟡' : 
                                stat.trainingLevel >= 40 ? '🟢' : 
                                stat.trainingLevel >= 20 ? '🔵' : '⚪')} ${stat.elementPlusAtk}`,
                            increaseElementDamage: stat.increaseElementDamage,
                            increaseAtk: stat.increaseAtk,
                            ammunition: stat.increaseMaxAmmunitionCapacity,
                            chargeSpeed: stat.increaseChargeSpeed,
                            chargeDamage: stat.increaseChargeDamage,
                            criticalRate: stat.increaseCriticalRate,
                            criticalDamage: stat.increaseCriticalDamage,
                            hitRate: stat.increaseHitRate,
                            defenseIncrease: stat.increaseDef,
                            attack: stat.atk.toLocaleString(),
                            item: (stat.itemGrade !== undefined && stat.itemGrade !== '' && stat.itemLevel !== undefined) ? `<span class="item-grade-${stat.itemGrade}">${stat.itemGrade} ${stat.itemLevel}</span>` : '',
                            skill1: stat.skill1,
                            skill2: stat.skill2,
                            skill3: stat.skill3
                        };
                        
                        let cellsHtml = '';
                        const columns = columnDefinitions.deck;
                        
                        columns.forEach(column => {
                            if (visibleColumns[column.id] !== false) {
                                let cellContent = columnData[column.id];
                                let cellAttributes = '';
                                
                                // 특별한 속성 처리
                                if (column.id === 'character') {
                                    cellAttributes = ' class="character-col"';
                                }
                                if (column.id === 'chargeSpeed' && stat.characterName === "앨리스" && stat.increaseChargeSpeed <= 8) {
                                    cellAttributes = ' style="color:red"';
                                }
                                
                                // rowspan 처리 (첫 번째 행에서만)
                                if (i === 0 && ['rank', 'nickname', 'level', 'deckPower'].includes(column.id)) {
                                    cellAttributes += ` rowspan="${rowCount}"`;
                                } else if (i > 0 && ['rank', 'nickname', 'level', 'deckPower'].includes(column.id)) {
                                    // 첫 번째 행이 아닌 경우 rowspan 컬럼은 생략
                                    return;
                                }
                                
                                cellsHtml += `<td${cellAttributes}>${cellContent}</td>`;
                            }
                        });
                        
                        tr.innerHTML = cellsHtml;
                        tbody.appendChild(tr);
                    });
                });
            } else {
                // 개별 모드: 기존 필터(캐릭터, 멤버 선택) 및 정렬 기능 적용
                let selectedData = [];
                members.forEach(member => {
                    member.characters.forEach(character => {
                        if ((selectedCharacter && character.name !== selectedCharacter) ||
                            (selectedMember && member.name !== selectedMember)) {
                            return;
                        }
                        const elementPlusAtk = Math.round(((1 + character.increaseAtk / 200) * (1 + character.increaseElementDamage / 100) - 1) * 10000) / 100;                                
                        const trainingLevel = elementPlusAtk;

                        selectedData.push({
                            memberName: member.name,                                    
                            syncroLevel: member.syncroLevel,
                            characterName: character.name,
                            upgrade: character.upgrade,
                            elementPower: Math.round(character.atk * (1 + character.increaseAtk / 200) * (1 + character.increaseElementDamage / 100)),
                            nonElementPower: Math.round(character.atk * (1 + character.increaseAtk / 200)),
                            elementPlusAtk: Math.round(((1 + character.increaseAtk / 200) * (1 + character.increaseElementDamage / 100) - 1) * 10000) / 100,
                            increaseElementDamage: character.increaseElementDamage || 0,
                            increaseAtk: character.increaseAtk || 0,
                            increaseChargeSpeed: character.increaseChargeSpeed || 0,
                            increaseMaxAmmunitionCapacity: character.increaseMaxAmmunitionCapacity || 0,
                            increaseChargeDamage: character.increaseChargeDamage || 0,
                            increaseCriticalRate: character.increaseCriticalRate || 0,
                            increaseCriticalDamage: character.increaseCriticalDamage || 0,
                            increaseHitRate: character.increaseHitRate || 0,
                            increaseDef: character.increaseDef || 0,
                            atk: character.atk,
                            skill1: character.skill1,
                            skill2: character.skill2,
                            skill3: character.skill3,
                            itemGrade: character.itemGrade,
                            itemLevel: character.itemLevel,
                            trainingLevel: trainingLevel,
                            element: character.element,
                        });
                    });
                });
                selectedData.sort((a, b) => b[sortBy] - a[sortBy]);

                const showNickname = selectedMember ? false : true;
                const showCharacter = selectedCharacter ? false : true;

                updateNormalHeader(sortBy, showNickname, showCharacter);

                selectedData.forEach((data, index) => {
                    const tr = document.createElement("tr");
                    
                    // 컬럼 데이터 매핑
                    const columnData = {
                        rank: index + 1,
                        nickname: data.memberName,
                        level: data.syncroLevel,
                        character: `${data.element ? (elementEmojis[data.element] + ' ') : ''} ${data.characterName}`,
                        upgrade: data.upgrade,
                        elementPlusAtk: `${(data.trainingLevel >= 100 ? '🔴' : 
                            data.trainingLevel >= 80 ? '🟠' : 
                            data.trainingLevel >= 60 ? '🟡' : 
                            data.trainingLevel >= 40 ? '🟢' : 
                            data.trainingLevel >= 20 ? '🔵' : '⚪')} ${data.elementPlusAtk}`,
                        increaseElementDamage: data.increaseElementDamage,
                        increaseAtk: data.increaseAtk,
                        ammunition: data.increaseMaxAmmunitionCapacity,
                        chargeSpeed: data.increaseChargeSpeed,
                        chargeDamage: data.increaseChargeDamage,
                        criticalRate: data.increaseCriticalRate,
                        criticalDamage: data.increaseCriticalDamage,
                        hitRate: data.increaseHitRate,
                        defenseIncrease: data.increaseDef,
                        attack: data.atk.toLocaleString(),
                        item: (data.itemGrade !== undefined && data.itemGrade !== '' && data.itemLevel !== undefined) ? `<span class="item-grade-${data.itemGrade}">${data.itemGrade} ${data.itemLevel}</span>` : '',
                        skill1: data.skill1,
                        skill2: data.skill2,
                        skill3: data.skill3
                    };
                    
                    let cellsHtml = '';
                    let columns = columnDefinitions.normal;
                    
                    // 조건부 컬럼 필터링
                    columns = columns.filter(column => {
                        if (column.conditional) {
                            if (column.id === 'nickname' && selectedMember) return false;
                            if (column.id === 'level' && selectedMember) return false;
                            if (column.id === 'character' && selectedCharacter) return false;
                        }
                        return true;
                    });
                    
                    columns.forEach(column => {
                        if (visibleColumns[column.id] !== false) {
                            let cellContent = columnData[column.id];
                            let cellAttributes = '';
                            
                            // 특별한 속성 처리
                            if (column.id === 'character') {
                                cellAttributes = ' class="character-col"';
                            }
                            if (column.id === 'chargeSpeed' && data.characterName === "앨리스" && data.increaseChargeSpeed <= 8) {
                                cellAttributes = ' style="color:red"';
                            }
                            
                            cellsHtml += `<td${cellAttributes}>${cellContent}</td>`;
                        }
                    });
                    
                    tr.innerHTML = cellsHtml;
                    tbody.appendChild(tr);
                });
            }
        }

        // 인덱스로 컬럼 ID 가져오기
        function getColumnIdByIndex(index) {
            const deckMode = document.getElementById('deckSelect').value !== "";
            const selectedCharacter = document.getElementById('characterSelect').value;
            const selectedMember = document.getElementById('memberSelect').value;
            
            let columns = columnDefinitions[deckMode ? 'deck' : 'normal'];
            
            // 조건부 컬럼 필터링
            if (!deckMode) {
                columns = columns.filter(column => {
                    if (column.conditional) {
                        if (column.id === 'nickname' && selectedMember) return false;
                        if (column.id === 'level' && selectedMember) return false;
                        if (column.id === 'character' && selectedCharacter) return false;
                    }
                    return true;
                });
            }
            
            return columns[index] ? columns[index].id : null;
        }

        // 덱 구성 정보를 미리 정의 (추후 덱이 추가될 때 유연하게 적용)
        const decks = {
            deck1: {
                name: '🟪 전격',
                characters: [
                    { weight: 1, type: 'element', name: '신데렐라' },
                    { weight: 1, type: 'element', name: '아니스 : 스파클링 서머' },
                    { weight: 1, type: 'element', name: '메이든 : 아이스 로즈' },
                    { weight: 1, type: 'element', name: '루주' },
                    { weight: 1, type: 'element', name: '마리' },
                ]
            },
            deck2: {
                name: '🟨 철갑',
                characters: [
                    { weight: 1, type: 'element', name: '라피 : 레드 후드' },
                    { weight: 1, type: 'element', name: '레드 후드' },
                    { weight: 1, type: 'element', name: '이브' },
                    { weight: 1, type: 'element', name: '레이븐' },
                    { weight: 1, type: 'element', name: '스노우 화이트' }
                ]
            },
            deck3: { 
                name: '🟥 작열',
                characters: [
                    { weight: 1, type: 'element', name: '라피 : 레드 후드'  },
                    { weight: 1, type: 'element', name: '미하라 : 본딩 체인' },
                    { weight: 1, type: 'element', name: '앨리스' },
                    { weight: 1, type: 'element', name: '아스카' },
                    { weight: 1, type: 'element', name: '레이' },
                    { weight: 1, type: 'element', name: '모더니아' },
                ]
            },
            deck4: {
                name: '🟦 수냉',
                characters: [
                    { weight: 1, type: 'element', name: '도로시 : 세렌디피티' },
                    { weight: 1, type: 'element', name: '헬름' },
                    { weight: 1, type: 'element', name: '루드밀라 : 윈터 오너' },
                    { weight: 1, type: 'element', name: '일레그 : 붐 앤 쇼크' },
                    { weight: 1, type: 'element', name: '브래디' },
                    { weight: 1, type: 'element', name: '퀀시 : 이스케이프 퀸' },
                ]
            },
            deck5: {
                name: '🟩 풍압',
                characters: [
                    { weight: 1, type: 'element', name: '홍련 : 흑영' },
                    { weight: 1, type: 'element', name: '아스카 : WILLE' },
                    { weight: 1, type: 'element', name: '레이 (가칭)' },
                    { weight: 1, type: 'element', name: '리틀 머메이드' },
                    { weight: 1, type: 'element', name: '마나' },
                ]
            }
        };

        fetch('data/data.json')
            .then(response => response.json())
            .then(data => {
                const seasonSelect = document.getElementById('seasonSelect');
                const seasons = Object.keys(data.seasons).sort((a, b) => b - a); // 숫자 내림차순
                seasons.forEach(season => {
                    const option = document.createElement('option');
                    option.value = season;
                    option.textContent = `시즌 ${season}`;
                    seasonSelect.appendChild(option);
                });

                let members = data.seasons[seasons[0]].members; // 최신 시즌으로 기본 설정

                seasonSelect.addEventListener('change', () => {
                    const selectedSeason = seasonSelect.value;
                    members = data.seasons[selectedSeason].members;
                    updateTable(); // 테이블을 다시 그립니다
                });

                const selectDeck = document.getElementById('deckSelect');
                const selectCharacter = document.getElementById('characterSelect');
                const selectMember = document.getElementById('memberSelect');
                const selectSort = document.getElementById('sortSelect');
                const tbody = document.getElementById('statsTable').querySelector('tbody');
                const tableHeader = document.getElementById('tableHeader');
                const deckMemberSelect = document.getElementById('deckMemberSelect');

                // 개별 모드용 드롭다운 채우기: 캐릭터, 멤버 목록
                const characterNamesSet = new Set();
                const memberNamesSet = [];

                members.sort((a, b) => b.syncroLevel - a.syncroLevel).forEach(member => {
                    memberNamesSet.push({ name: member.name, syncroLevel: member.syncroLevel });
                    member.characters.forEach(character => {
                        characterNamesSet.add(character.name);
                    });
                });

                // 특정 캐릭터를 최상단에 위치시키기
                const priorityCharacters = [
                    // 전격
                    "💜 신데렐라",
                    "💜 아니스 : 스파클링 서머",
                    "💜 메이든 : 아이스 로즈",                     
                    // 풍압
                    "💚 홍련 : 흑영", 
                    "💚 아스카 : WILLE",
                    "💚 레이 (가칭)",
                    "💚 리틀 머메이드",
                    // 작열
                    "❤️ 앨리스", 
                    "❤️ 미하라 : 본딩 체인",
                    "❤️ 아스카",
                    "❤️ 레이",
                    "❤️ 모더니아",
                    // 철갑
                    "💛 라피 : 레드 후드", 
                    "💛 레드 후드",
                    "💛 이브",
                    "💛 레이븐",
                    "💛 스노우 화이트",
                    // 수냉
                    "💙 도로시 : 세렌디피티", 
                    "💙 헬름", 
                    "💙 루드밀라 : 윈터 오너",
                    "💙 일레그 : 붐 앤 쇼크",
                    "💙 퀀시 : 이스케이프 퀸",
                    "💙 브래디",
                    "💙 일레그 : 붐 앤 쇼크"
                ];

                // priorityCharacters 배열 위에 element 매핑 추가
                const elementEmojis = {
                    "전격": "🟪",
                    "철갑": "🟨",
                    "작열": "🟥", 
                    "수냉": "🟦",
                    "풍압": "🟩"
                };
                
                // 우선순위 캐릭터를 먼저 추가
                priorityCharacters.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name.slice(3); // 이모지 제거
                    option.innerHTML = name;
                    selectCharacter.appendChild(option);
                });

                const sortedCharacters = Array.from(characterNamesSet)
                    .sort()
                    .filter(name => !priorityCharacters.includes(name)); // 우선순위 캐릭터 제외

                // 나머지 캐릭터를 이름 순으로 추가
                sortedCharacters.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    selectCharacter.appendChild(option);
                });

                memberNamesSet.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member.name;
                    option.textContent = `${member.name} (${member.syncroLevel})`;
                    selectMember.appendChild(option);
                });

                function updateDeckMemberSelect() {
                    // 현재 선택된 값 저장
                    const prevValue = deckMemberSelect.value;
                    deckMemberSelect.innerHTML = '<option value="">-- 멤버 선택 --</option>';
                    members.forEach(member => {
                        const option = document.createElement('option');
                        option.value = member.name;
                        option.textContent = `${member.name} (${member.syncroLevel})`;
                        deckMemberSelect.appendChild(option);
                    });
                    // 이전 선택값 복원
                    if (prevValue) deckMemberSelect.value = prevValue;
                }

                // 개별 모드 헤더 업데이트 (정렬 기준 컬럼 우측에 ▼ 표시)
                function updateNormalHeader(sortBy, showNickname, showCharacter) {
                    let columns = columnDefinitions.normal;
                    
                    // 조건부 컬럼 필터링
                    columns = columns.filter(column => {
                        if (column.conditional) {
                            if (column.id === 'nickname' && !showNickname) return false;
                            if (column.id === 'level' && !showNickname) return false;
                            if (column.id === 'character' && !showCharacter) return false;
                        }
                        return true;
                    });
                    
                    let headerHtml = '<tr>';
                    columns.forEach(column => {
                        if (visibleColumns[column.id] !== false) {
                            let headerText = column.name;
                            let headerClass = '';
                            
                            // 정렬 표시
                            const headers = {
                                "elementPlusAtk": "파워",
                                "increaseElementDamage": "우코",
                                "increaseAtk": "공증",
                                "trainingLevel": "파워"
                            };
                            
                            if (headers[sortBy] === column.name) {
                                headerText += " ▼";
                            }
                            
                            // 특별한 클래스 처리
                            if (column.id === 'nickname') {
                                headerClass = ' class="nickname-col"';
                            } else if (column.id === 'character') {
                                headerClass = ' class="character-col"';
                            }
                            
                            headerHtml += `<th${headerClass}>${headerText}</th>`;
                        }
                    });
                    headerHtml += '</tr>';
                    
                    tableHeader.innerHTML = headerHtml;
                }

                // 덱 모드용 헤더 업데이트 (단일 행 헤더)
                function updateDeckHeader() {
                    const columns = columnDefinitions.deck;
                    let headerHtml = '<tr>';
                    
                    columns.forEach(column => {
                        if (visibleColumns[column.id] !== false) {
                            let rowspanAttr = '';
                            let headerText = column.name;
                            
                            // rowspan이 필요한 컬럼들
                            if (['rank', 'nickname', 'level', 'deckPower'].includes(column.id)) {
                                rowspanAttr = ' rowspan="2"';
                            }
                            
                            // 정렬 표시
                            if (column.id === 'deckPower') {
                                headerText += ' ▼';
                            }
                            
                            headerHtml += `<th${rowspanAttr}>${headerText}</th>`;
                        }
                    });
                    
                    headerHtml += '</tr>';
                    tableHeader.innerHTML = headerHtml;
                }

                // updateTable 함수: 덱 모드와 개별 모드를 모두 지원
                function updateTable() {
                    const deckMode = selectDeck.value !== "";
                    updateDeckMemberSelect();
                    
                    // 컬럼 체크박스 업데이트
                    createColumnCheckboxes(deckMode ? 'deck' : 'normal');
                    
                    // 테이블 내용 렌더링
                    renderTableContent();
                }

                // 이벤트 리스너 등록
                selectDeck.addEventListener("change", updateTable);
                selectCharacter.addEventListener("change", updateTable);
                selectMember.addEventListener("change", updateTable);
                selectSort.addEventListener("change", updateTable);
                deckMemberSelect.addEventListener("change", updateTable);

                // 초기 헤더 설정 (개별 모드 기본)
                updateNormalHeader(selectSort.value);
                
                // 초기 컬럼 체크박스 생성
                createColumnCheckboxes('normal');

                updateTable(); // 초기 테이블 업데이트
            })
            .catch(error => console.error("JSON 파일 로딩 중 오류:", error));
    </script>
</body>

</html>