<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <title>캐릭터 스탯 테이블</title>
  <style>
    table {
      width: 90%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    table,
    th,
    td {
      border: 1px solid #ccc;
    }
    th,
    td {
      padding: 8px;
      text-align: center;
    }
  </style>
</head>

<body>
  <h1>캐릭터 스탯 조회</h1>

  <!-- 덱 선택: 덱 모드 전환 (옵션 텍스트: '신수클') -->
  <label for="deckSelect">덱 선택: </label>
  <select id="deckSelect">
    <option value="">-- 선택 안함 (개별 보기) --</option>
    <option value="deck1">신수클</option>
  </select>

  <!-- 개별 모드용 드롭다운 -->
  <label for="characterSelect">캐릭터 선택: </label>
  <select id="characterSelect">
    <option value="">-- 선택하세요 --</option>
  </select>

  <label for="memberSelect">멤버 선택: </label>
  <select id="memberSelect">
    <option value="">-- 선택하세요 --</option>
  </select>

  <!-- 정렬 기준 (개별 모드에 적용, 덱 모드에서는 덱 파워 기준) -->
  <label for="sortSelect">정렬 기준: </label>
  <select id="sortSelect">
    <option value="elementPower">우코 파워</option>
    <option value="nonElementPower">비우코 파워</option>
    <option value="elementPlusAtk">우코x공증</option>
    <option value="increaseElementDamage">우코</option>
    <option value="increaseAtk">공증</option>
  </select>

  <!-- 스탯 출력 테이블 -->
  <table id="statsTable">
    <thead id="tableHeader">
      <!-- 개별 모드 기본 헤더 -->
      <tr>
        <th>순위</th>
        <th class="nickname-col">닉네임</th>
        <th class="character-col">캐릭터</th>
        <th>우코 파워</th>
        <th>비우코 파워</th>
        <th>우코x공증</th>
        <th>우코</th>
        <th>공증</th>
        <th>공격력</th>
        <th>스킬1</th>
        <th>스킬2</th>
        <th>스킬3</th>
      </tr>
    </thead>
    <tbody>
      <!-- JavaScript로 동적 생성 -->
    </tbody>
  </table>

  <script>
    // 덱 구성을 미리 정의 (추후 덱 추가/변경 가능)
    const decks = {
      deck1: {
        name: '신수클', // 덱 선택 옵션에 표시할 텍스트
        // 이번 예시에서는 덱에 포함된 캐릭터 3종류 (개별 모드에서는 모두 표시됨)
        characters: ['신데렐라', '아니스 : 스파클링 서머', '메이든 : 아이스 로즈']
      }
    };

    fetch('data/data.json')
      .then(response => response.json())
      .then(data => {
        const members = data.members;
        const selectDeck = document.getElementById('deckSelect');
        const selectCharacter = document.getElementById('characterSelect');
        const selectMember = document.getElementById('memberSelect');
        const selectSort = document.getElementById('sortSelect');
        const tbody = document.getElementById('statsTable').querySelector('tbody');
        const tableHeader = document.getElementById('tableHeader');

        // 개별 모드용 드롭다운 채우기: 캐릭터, 멤버 목록
        const characterNamesSet = new Set();
        const memberNamesSet = new Set();
        members.forEach(member => {
          memberNamesSet.add(member.name);
          member.Characters.forEach(character => {
            characterNamesSet.add(character.name);
          });
        });
        Array.from(characterNamesSet).sort().forEach(name => {
          const option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          selectCharacter.appendChild(option);
        });
        Array.from(memberNamesSet).sort().forEach(name => {
          const option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          selectMember.appendChild(option);
        });

        // 개별 모드용 헤더 업데이트 (정렬 기준 컬럼 우측에 ▼ 표시)
        function updateNormalHeader(sortBy) {
          tableHeader.innerHTML = `<tr>
              <th>순위</th>
              <th class="nickname-col">닉네임</th>
              <th class="character-col">캐릭터</th>
              <th>우코 파워</th>
              <th>비우코 파워</th>
              <th>우코x공증</th>
              <th>우코</th>
              <th>공증</th>
              <th>공격력</th>
              <th>스킬1</th>
              <th>스킬2</th>
              <th>스킬3</th>
            </tr>`;
          const headers = {
            "elementPower": "우코 파워",
            "nonElementPower": "비우코 파워",
            "elementPlusAtk": "우코x공증",
            "increaseElementDamage": "우코",
            "increaseAtk": "공증"
          };
          tableHeader.querySelectorAll("th").forEach(th => {
            if (th.textContent === headers[sortBy]) {
              th.textContent += " ▼";
            }
          });
        }

        // 덱 모드용 헤더 업데이트 (2행 헤더; 순위, 닉네임, 덱 파워, 그리고 '신수클'으로 merge 셀)
        function updateDeckHeader() {
          const headerHTML = '<tr>' +
            '<th rowspan="2">순위</th>' +
            '<th rowspan="2">닉네임</th>' +
            '<th rowspan="2">덱 파워</th>' +
            '<th colspan="2">신수클</th>' +
            '</tr>' +
            '<tr>' +
            '<th>우코 파워</th><th>우코x공증</th>' +
            '</tr>';
          tableHeader.innerHTML = headerHTML;
        }

        // updateTable 함수: 덱 모드와 개별 모드를 모두 지원
        function updateTable() {
          const deckMode = selectDeck.value !== "";
          const selectedCharacter = selectCharacter.value;
          const selectedMember = selectMember.value;
          const sortBy = selectSort.value;
          tbody.innerHTML = "";

          if (deckMode) {
            // 덱 모드: 덱에 정의된 캐릭터 조합(현재 deck1)을 모두 보유한 멤버만 표시
            const deck = decks[selectDeck.value];
            let deckData = [];
            members.forEach(member => {
              let hasAll = true;
              let totalElementPower = 0;
              let totalElementPlusAtk = 0;
              deck.characters.forEach(deckChar => {
                const charData = member.Characters.find(c => c.name === deckChar);
                if (charData) {
                  const elementPower = Math.round(charData.atk * (1 + charData.increaseAtk / 100) * (1 + charData.increaseElementDamage / 100));
                  const elementPlusAtk = Math.round(((1 + charData.increaseAtk / 100) * (1 + charData.increaseElementDamage / 100) - 1) * 10000) / 100;
                  totalElementPower += elementPower;
                  totalElementPlusAtk += elementPlusAtk;
                } else {
                  hasAll = false;
                }
              });
              if (hasAll) {
                deckData.push({
                  memberName: member.name,
                  deckPower: totalElementPower,
                  deckPlus: totalElementPlusAtk
                });
              }
            });
            // 덱 모드에서는 덱 파워 기준 내림차순 정렬
            deckData.sort((a, b) => b.deckPower - a.deckPower);
            updateDeckHeader();
            deckData.forEach((data, index) => {
              const tr = document.createElement("tr");
              // 데이터 행: 순위, 닉네임, 덱 파워, 그리고 '신수클' 그룹에 대해 우코 파워(덱 파워)와 우코x공증 출력
              const rowHTML = `<td>${index + 1}</td>
                <td>${data.memberName}</td>
                <td>${data.deckPower}</td>
                <td>${data.deckPower}</td>
                <td>${data.deckPlus}</td>`;
              tr.innerHTML = rowHTML;
              tbody.appendChild(tr);
            });
          } else {
            // 개별 모드: 기존 필터(캐릭터, 멤버 선택) 및 정렬 기능 적용
            let selectedData = [];
            members.forEach(member => {
              member.Characters.forEach(character => {
                if ((selectedCharacter && character.name !== selectedCharacter) ||
                    (selectedMember && member.name !== selectedMember)) {
                  return;
                }
                selectedData.push({
                  memberName: member.name,
                  characterName: character.name,
                  elementPower: Math.round(character.atk * (1 + character.increaseAtk / 100) * (1 + character.increaseElementDamage / 100)),
                  nonElementPower: Math.round(character.atk * (1 + character.increaseAtk / 100)),
                  elementPlusAtk: Math.round(((1 + character.increaseAtk / 100) * (1 + character.increaseElementDamage / 100) - 1) * 10000) / 100,
                  increaseElementDamage: character.increaseElementDamage,
                  increaseAtk: character.increaseAtk,
                  atk: character.atk,
                  skill1: character.skill1,
                  skill2: character.skill2,
                  skill3: character.skill3
                });
              });
            });
            selectedData.sort((a, b) => b[sortBy] - a[sortBy]);
            updateNormalHeader(sortBy);
            // 만약 특정 멤버가 선택되면 닉네임 컬럼 숨기, 특정 캐릭터 선택 시 캐릭터 컬럼 숨김
            const showNickname = selectedMember ? false : true;
            const showCharacter = selectedCharacter ? false : true;
            selectedData.forEach((data, index) => {
              const tr = document.createElement("tr");
              tr.innerHTML = `
                <td>${index + 1}</td>
                ${showNickname ? `<td>${data.memberName}</td>` : ""}
                ${showCharacter ? `<td>${data.characterName}</td>` : ""}
                <td>${data.elementPower}</td>
                <td>${data.nonElementPower}</td>
                <td>${data.elementPlusAtk}</td>
                <td>${data.increaseElementDamage}</td>
                <td>${data.increaseAtk}</td>
                <td>${data.atk}</td>
                <td>${data.skill1}</td>
                <td>${data.skill2}</td>
                <td>${data.skill3}</td>
              `;
              tbody.appendChild(tr);
            });
          }
        }

        // 이벤트 리스너 등록
        selectDeck.addEventListener("change", updateTable);
        selectCharacter.addEventListener("change", updateTable);
        selectMember.addEventListener("change", updateTable);
        selectSort.addEventListener("change", updateTable);
        // 초기 헤더 설정 (개별 모드 기본)
        updateNormalHeader(selectSort.value);
      })
      .catch(error => console.error("JSON 파일 로딩 중 오류:", error));
  </script>
</body>

</html>
